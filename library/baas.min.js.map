{"version":3,"sources":["webpack:///baas.min.js","webpack:///webpack/bootstrap b892022d7770bbce47d1?0cb5","webpack:///./distribution/client.js?77eb","webpack:///./distribution/auth.js?82ee","webpack:///./distribution/common.js?89c4","webpack:///./~/js-base64/base64.js?e686","webpack:///./~/buffer/index.js?1a55","webpack:///./~/base64-js/index.js?2add","webpack:///./~/ieee754/index.js?70fe","webpack:///./~/isarray/index.js?eabc","webpack:///./~/isomorphic-fetch/fetch-npm-browserify.js?7723","webpack:///./~/whatwg-fetch/fetch.js?1c20"],"names":["Baas","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","default","_interopRequireDefault","_classCallCheck","instance","Constructor","TypeError","defineProperty","value","Admin","MongoClient","BaasClient","ErrInvalidSession","ErrAuthProviderNotFound","undefined","_typeof","Symbol","iterator","constructor","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","protoProps","staticProps","_auth","_auth2","_common","common","toQueryString","parts","push","encodeURIComponent","join","clientAppID","options","this","baseUrl","DEFAULT_BAAS_SERVER_URL","appUrl","authUrl","authManager","handleRedirect","providerName","redirectUrl","window","location","replace","getOAuthLoginURL","authedId","get","error","_this","_doAuthed","refreshOnFailure","useRefreshToken","then","data","clear","resource","method","url","init","headers","Accept","JSONTYPE","Content-Type","body","queryParams","fetch","response","status","Promise","resolve","json","BaasError","Error","statusText","_this2","auth","reject","token","getRefreshToken","_error","_refreshToken","_this3","isImpersonatingUser","refreshImpersonation","setAccessToken","stages","responseDecoder","JSON","parse","responseEncoder","stringify","decoder","encoder","arrayBuffer","buffer","buf","TextDecoder","decode","DB","client","service","name","Collection","db","database","collection","query","args","getBaseArgs","singleDoc","executePipeline","action","project","docs","toInsert","Array","from","arguments","items","update","upsert","multi","makeUpdateStage","baasClient","serviceName","_this4","root","keys","list","_get","create","_post","apiKey","keyId","remove","_delete","enable","_put","disable","_this5","app","appID","users","filter","user","uid","logout","sandbox","userId","user_id","authProviders","provider","authType","authName","variables","variable","varName","logs","apiKeys","services","svc","setConfig","rules","rule","ruleId","triggers","trigger","triggerId","_this6","startImpersonation","stopImpersonation","_jsBase","AuthDataStorage","_data","val","String","Auth","rootUrl","localStorage","authDataStorage","protocol","host","pathname","currAuth","getItem","REFRESH_TOKEN_KEY","set","ourState","STATE_KEY","redirectFragment","hash","substring","redirectState","parseRedirectFragment","lastError","console","history","replaceState","pageRootUrl","found","removeItem","stateValid","ua","state","generateState","setItem","result","encodeURI","cors","checkStatus","username","password","USER_AUTH_KEY","clearImpersonation","rt","log","Base64","encode","_id","$oid","IMPERSONATION_ACTIVE_KEY","IMPERSONATION_USER_KEY","catch","e","realUserAuth","IMPERSONATION_REAL_USER_AUTH_KEY","alpha","stateLength","pos","Math","floor","random","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","setPrototypeOf","__proto__","BAAS_ERROR_KEY","BAAS_LINK_KEY","fragment","vars","split","shouldBreak","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","next","done","pair","pairParts","pairKey","decodeURIComponent","atob","theirState","err","return","_Error","message","code","getPrototypeOf","captureStackTrace","stack","global","_Base64","version","Buffer","b64chars","b64tab","bin","t","l","charAt","fromCharCode","cb_utob","cc","charCodeAt","re_utob","utob","u","cb_encode","ccc","padlen","ord","chars","btoa","b","_encode","toString","urisafe","m0","re_btou","RegExp","cb_btou","cccc","cp","offset","btou","cb_decode","len","n","a","_decode","noConflict","VERSION","fromBase64","toBase64","noEnum","v","extendString","typedArraySupport","arr","Uint8Array","foo","subarray","byteLength","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","arg","encodingOrOffset","allocUnsafe","ArrayBuffer","fromArrayBuffer","fromString","fromObject","assertSize","size","alloc","fill","encoding","checked","string","isEncoding","actual","write","slice","fromArrayLike","array","byteOffset","isBuffer","copy","isnan","type","isArray","SlowBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","start","end","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","bidirectionalIndexOf","dir","isNaN","arrayIndexOf","indexOf","lastIndexOf","read","indexSize","readUInt16BE","arrLength","valLength","foundIndex","j","hexWrite","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","base64","fromByteArray","min","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","apply","ret","out","toHex","bytes","checkOffset","ext","checkInt","max","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","str","stringtrim","INVALID_BASE64_RE","trim","units","Infinity","leadSurrogate","byteArray","hi","lo","toByteArray","src","dst","INSPECT_MAX_BYTES","poolSize","_augment","species","allocUnsafeSlow","_isBuffer","compare","x","y","concat","swap16","swap32","swap64","equals","inspect","match","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","maxBytes","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","placeHoldersCount","b64","tmp","placeHolders","Arr","L","revLookup","tripletToBase64","num","lookup","encodeChunk","uint8","output","extraBytes","maxChunkLength","len2","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","d","s","NaN","abs","LN2","bind","normalizeName","test","normalizeValue","iteratorFor","shift","support","iterable","Headers","map","forEach","append","getOwnPropertyNames","consumed","bodyUsed","fileReaderReady","reader","onload","onerror","readBlobAsArrayBuffer","blob","FileReader","promise","readAsArrayBuffer","readBlobAsText","readAsText","readArrayBufferAsText","view","bufferClone","Body","_initBody","_bodyInit","_bodyText","Blob","isPrototypeOf","_bodyBlob","formData","FormData","_bodyFormData","searchParams","URLSearchParams","isDataView","_bodyArrayBuffer","isArrayBufferView","rejected","text","normalizeMethod","upcased","toUpperCase","methods","Request","input","credentials","mode","referrer","form","parseHeaders","rawHeaders","line","Response","bodyInit","ok","viewClasses","DataView","oldValue","has","callback","thisArg","values","entries","clone","redirectStatuses","redirect","request","xhr","XMLHttpRequest","getAllResponseHeaders","responseURL","responseText","ontimeout","open","withCredentials","responseType","setRequestHeader","send","polyfill"],"mappings":"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","file":"baas.min.js","sourcesContent":["var Baas =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Admin = exports.MongoClient = exports.BaasClient = exports.ErrInvalidSession = exports.ErrAuthProviderNotFound = undefined;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _auth = __webpack_require__(1);\n\t\n\tvar _auth2 = _interopRequireDefault(_auth);\n\t\n\tvar _common = __webpack_require__(2);\n\t\n\tvar common = _interopRequireWildcard(_common);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/* global window, fetch */\n\t/* eslint no-labels: ['error', { 'allowLoop': true }] */\n\t__webpack_require__(8);\n\t\n\tvar ErrAuthProviderNotFound = exports.ErrAuthProviderNotFound = 'AuthProviderNotFound';\n\tvar ErrInvalidSession = exports.ErrInvalidSession = 'InvalidSession';\n\t\n\tvar toQueryString = function toQueryString(obj) {\n\t  var parts = [];\n\t  for (var i in obj) {\n\t    if (obj.hasOwnProperty(i)) {\n\t      parts.push(encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]));\n\t    }\n\t  }\n\t  return parts.join('&');\n\t};\n\t\n\tvar BaasClient = exports.BaasClient = function () {\n\t  function BaasClient(clientAppID, options) {\n\t    _classCallCheck(this, BaasClient);\n\t\n\t    var baseUrl = common.DEFAULT_BAAS_SERVER_URL;\n\t    if (options && options.baseUrl) {\n\t      baseUrl = options.baseUrl;\n\t    }\n\t    this.appUrl = baseUrl + '/admin/v1';\n\t    this.authUrl = baseUrl + '/admin/v1/auth';\n\t    if (clientAppID) {\n\t      this.appUrl = baseUrl + '/v1/app/' + clientAppID;\n\t      this.authUrl = this.appUrl + '/auth';\n\t    }\n\t    this.authManager = new _auth2.default(this.authUrl);\n\t    this.authManager.handleRedirect();\n\t  }\n\t\n\t  _createClass(BaasClient, [{\n\t    key: 'authWithOAuth',\n\t    value: function authWithOAuth(providerName, redirectUrl) {\n\t      window.location.replace(this.authManager.getOAuthLoginURL(providerName, redirectUrl));\n\t    }\n\t  }, {\n\t    key: 'authedId',\n\t    value: function authedId() {\n\t      return this.authManager.authedId();\n\t    }\n\t  }, {\n\t    key: 'auth',\n\t    value: function auth() {\n\t      return this.authManager.get();\n\t    }\n\t  }, {\n\t    key: 'authError',\n\t    value: function authError() {\n\t      return this.authManager.error();\n\t    }\n\t  }, {\n\t    key: 'logout',\n\t    value: function logout() {\n\t      var _this = this;\n\t\n\t      return this._doAuthed('/auth', 'DELETE', { refreshOnFailure: false, useRefreshToken: true }).then(function (data) {\n\t        _this.authManager.clear();\n\t      });\n\t    }\n\t\n\t    // wrapper around fetch() that matches the signature of doAuthed but does not\n\t    // actually use any auth. This is necessary for routes that must be\n\t    // accessible without logging in, like listing available auth providers.\n\t\n\t  }, {\n\t    key: '_do',\n\t    value: function _do(resource, method, options) {\n\t      options = options || {};\n\t      var url = '' + this.appUrl + resource;\n\t      var init = {\n\t        method: method,\n\t        headers: { 'Accept': common.JSONTYPE, 'Content-Type': common.JSONTYPE }\n\t      };\n\t      if (options.body) {\n\t        init['body'] = options.body;\n\t      }\n\t      if (options.queryParams) {\n\t        url = url + '?' + toQueryString(options.queryParams);\n\t      }\n\t\n\t      return fetch(url, init).then(function (response) {\n\t        // Okay: passthrough\n\t        if (response.status >= 200 && response.status < 300) {\n\t          return Promise.resolve(response);\n\t        } else if (response.headers.get('Content-Type') === common.JSONTYPE) {\n\t          return response.json().then(function (json) {\n\t            var error = new common.BaasError(json['error'], json['errorCode']);\n\t            error.response = response;\n\t            throw error;\n\t          });\n\t        }\n\t        var error = new Error(response.statusText);\n\t        error.response = response;\n\t        throw error;\n\t      }).then(function (response) {\n\t        return response.json();\n\t      });\n\t    }\n\t  }, {\n\t    key: '_doAuthed',\n\t    value: function _doAuthed(resource, method, options) {\n\t      var _this2 = this;\n\t\n\t      if (options === undefined) {\n\t        options = { refreshOnFailure: true, useRefreshToken: false };\n\t      } else {\n\t        if (options.refreshOnFailure === undefined) {\n\t          options.refreshOnFailure = true;\n\t        }\n\t        if (options.useRefreshToken === undefined) {\n\t          options.useRefreshToken = false;\n\t        }\n\t      }\n\t\n\t      if (this.auth() === null) {\n\t        return Promise.reject(new common.BaasError('Must auth first'));\n\t      }\n\t\n\t      var url = '' + this.appUrl + resource;\n\t\n\t      var headers = {\n\t        'Accept': common.JSONTYPE,\n\t        'Content-Type': common.JSONTYPE\n\t      };\n\t      var token = options.useRefreshToken ? this.authManager.getRefreshToken() : this.auth()['accessToken'];\n\t      headers['Authorization'] = 'Bearer ' + token;\n\t\n\t      var init = {\n\t        method: method,\n\t        headers: headers\n\t      };\n\t\n\t      if (options.body) {\n\t        init['body'] = options.body;\n\t      }\n\t\n\t      if (options.queryParams) {\n\t        url = url + '?' + toQueryString(options.queryParams);\n\t      }\n\t\n\t      return fetch(url, init).then(function (response) {\n\t        // Okay: passthrough\n\t        if (response.status >= 200 && response.status < 300) {\n\t          return Promise.resolve(response);\n\t        } else if (response.headers.get('Content-Type') === common.JSONTYPE) {\n\t          return response.json().then(function (json) {\n\t            // Only want to try refreshing token when there's an invalid session\n\t            if ('errorCode' in json && json['errorCode'] === ErrInvalidSession) {\n\t              if (!options.refreshOnFailure) {\n\t                _this2.authManager.clear();\n\t                var _error = new common.BaasError(json['error'], json['errorCode']);\n\t                _error.response = response;\n\t                throw _error;\n\t              }\n\t\n\t              return _this2._refreshToken().then(function () {\n\t                options.refreshOnFailure = false;\n\t                return _this2._doAuthed(resource, method, options);\n\t              });\n\t            }\n\t\n\t            var error = new common.BaasError(json['error'], json['errorCode']);\n\t            error.response = response;\n\t            throw error;\n\t          });\n\t        }\n\t\n\t        var error = new Error(response.statusText);\n\t        error.response = response;\n\t        throw error;\n\t      });\n\t    }\n\t  }, {\n\t    key: '_refreshToken',\n\t    value: function _refreshToken() {\n\t      var _this3 = this;\n\t\n\t      if (this.authManager.isImpersonatingUser()) {\n\t        return this.authManager.refreshImpersonation(this);\n\t      }\n\t      return this._doAuthed('/auth/newAccessToken', 'POST', { refreshOnFailure: false, useRefreshToken: true }).then(function (response) {\n\t        return response.json().then(function (json) {\n\t          _this3.authManager.setAccessToken(json['accessToken']);\n\t          return Promise.resolve();\n\t        });\n\t      });\n\t    }\n\t  }, {\n\t    key: 'executePipeline',\n\t    value: function executePipeline(stages, options) {\n\t      var responseDecoder = JSON.parse;\n\t      var responseEncoder = JSON.stringify;\n\t      if (options) {\n\t        if (options.decoder) {\n\t          if (typeof options.decoder !== 'function') {\n\t            throw new Error('decoder option must be a function, but \"' + _typeof(options.decoder) + '\" was provided');\n\t          }\n\t          responseDecoder = options.decoder;\n\t        }\n\t        if (options.encoder) {\n\t          if (typeof options.encoder !== 'function') {\n\t            throw new Error('encoder option must be a function, but \"' + _typeof(options.encoder) + '\" was provided');\n\t          }\n\t          responseEncoder = options.encoder;\n\t        }\n\t      }\n\t      return this._doAuthed('/pipeline', 'POST', { body: responseEncoder(stages) }).then(function (response) {\n\t        if (response.arrayBuffer) {\n\t          return response.arrayBuffer();\n\t        }\n\t        return response.buffer();\n\t      }).then(function (buf) {\n\t        return new common.TextDecoder('utf-8').decode(buf);\n\t      }).then(function (body) {\n\t        return responseDecoder(body);\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return BaasClient;\n\t}();\n\t\n\tvar DB = function () {\n\t  function DB(client, service, name) {\n\t    _classCallCheck(this, DB);\n\t\n\t    this.client = client;\n\t    this.service = service;\n\t    this.name = name;\n\t  }\n\t\n\t  _createClass(DB, [{\n\t    key: 'getCollection',\n\t    value: function getCollection(name) {\n\t      return new Collection(this, name);\n\t    }\n\t  }]);\n\t\n\t  return DB;\n\t}();\n\t\n\tvar Collection = function () {\n\t  function Collection(db, name) {\n\t    _classCallCheck(this, Collection);\n\t\n\t    this.db = db;\n\t    this.name = name;\n\t  }\n\t\n\t  _createClass(Collection, [{\n\t    key: 'getBaseArgs',\n\t    value: function getBaseArgs() {\n\t      return {\n\t        'database': this.db.name,\n\t        'collection': this.name\n\t      };\n\t    }\n\t  }, {\n\t    key: 'deleteOne',\n\t    value: function deleteOne(query) {\n\t      var args = this.getBaseArgs();\n\t      args.query = query;\n\t      args.singleDoc = true;\n\t      return this.db.client.executePipeline([{\n\t        'service': this.db.service,\n\t        'action': 'delete',\n\t        'args': args\n\t      }]);\n\t    }\n\t  }, {\n\t    key: 'deleteMany',\n\t    value: function deleteMany(query) {\n\t      var args = this.getBaseArgs();\n\t      args.query = query;\n\t      args.singleDoc = false;\n\t      return this.db.client.executePipeline([{\n\t        'service': this.db.service,\n\t        'action': 'delete',\n\t        'args': args\n\t      }]);\n\t    }\n\t  }, {\n\t    key: 'find',\n\t    value: function find(query, project) {\n\t      var args = this.getBaseArgs();\n\t      args.query = query;\n\t      args.project = project;\n\t      return this.db.client.executePipeline([{\n\t        'service': this.db.service,\n\t        'action': 'find',\n\t        'args': args\n\t      }]);\n\t    }\n\t  }, {\n\t    key: 'insert',\n\t    value: function insert(docs) {\n\t      var toInsert = void 0;\n\t      if (docs instanceof Array) {\n\t        toInsert = docs;\n\t      } else {\n\t        toInsert = Array.from(arguments);\n\t      }\n\t\n\t      return this.db.client.executePipeline([{ 'action': 'literal',\n\t        'args': {\n\t          'items': toInsert\n\t        }\n\t      }, {\n\t        'service': this.db.service,\n\t        'action': 'insert',\n\t        'args': this.getBaseArgs()\n\t      }]);\n\t    }\n\t  }, {\n\t    key: 'makeUpdateStage',\n\t    value: function makeUpdateStage(query, update, upsert, multi) {\n\t      var args = this.getBaseArgs();\n\t      args.query = query;\n\t      args.update = update;\n\t      if (upsert) {\n\t        args.upsert = true;\n\t      }\n\t      if (multi) {\n\t        args.multi = true;\n\t      }\n\t\n\t      return {\n\t        'service': this.db.service,\n\t        'action': 'update',\n\t        'args': args\n\t      };\n\t    }\n\t  }, {\n\t    key: 'updateOne',\n\t    value: function updateOne(query, update) {\n\t      return this.db.client.executePipeline([this.makeUpdateStage(query, update, false, false)]);\n\t    }\n\t  }, {\n\t    key: 'updateMany',\n\t    value: function updateMany(query, update, upsert, multi) {\n\t      return this.db.client.executePipeline([this.makeUpdateStage(query, update, false, true)]);\n\t    }\n\t  }, {\n\t    key: 'upsert',\n\t    value: function upsert(query, update) {\n\t      return this.db.client.executePipeline([this.makeUpdateStage(query, update, true, false)]);\n\t    }\n\t  }]);\n\t\n\t  return Collection;\n\t}();\n\t\n\tvar MongoClient = exports.MongoClient = function () {\n\t  function MongoClient(baasClient, serviceName) {\n\t    _classCallCheck(this, MongoClient);\n\t\n\t    this.baasClient = baasClient;\n\t    this.service = serviceName;\n\t  }\n\t\n\t  _createClass(MongoClient, [{\n\t    key: 'getDb',\n\t    value: function getDb(name) {\n\t      return new DB(this.baasClient, this.service, name);\n\t    }\n\t  }]);\n\t\n\t  return MongoClient;\n\t}();\n\t\n\tvar Admin = exports.Admin = function () {\n\t  function Admin(baseUrl) {\n\t    _classCallCheck(this, Admin);\n\t\n\t    this.client = new BaasClient('', { baseUrl: baseUrl });\n\t  }\n\t\n\t  _createClass(Admin, [{\n\t    key: '_doAuthed',\n\t    value: function _doAuthed(url, method, options) {\n\t      return this.client._doAuthed(url, method, options).then(function (response) {\n\t        return response.json();\n\t      });\n\t    }\n\t  }, {\n\t    key: '_get',\n\t    value: function _get(url, queryParams) {\n\t      return this._doAuthed(url, 'GET', { queryParams: queryParams });\n\t    }\n\t  }, {\n\t    key: '_put',\n\t    value: function _put(url, queryParams) {\n\t      return this._doAuthed(url, 'PUT', { queryParams: queryParams });\n\t    }\n\t  }, {\n\t    key: '_delete',\n\t    value: function _delete(url) {\n\t      return this._doAuthed(url, 'DELETE');\n\t    }\n\t  }, {\n\t    key: '_post',\n\t    value: function _post(url, body) {\n\t      return this._doAuthed(url, 'POST', { body: JSON.stringify(body) });\n\t    }\n\t  }, {\n\t    key: 'profile',\n\t    value: function profile() {\n\t      var _this4 = this;\n\t\n\t      var root = this;\n\t      return {\n\t        keys: function keys() {\n\t          return {\n\t            list: function list() {\n\t              return root._get('/profile/keys');\n\t            },\n\t            create: function create(key) {\n\t              return root._post('/profile/keys');\n\t            },\n\t            apiKey: function apiKey(keyId) {\n\t              return {\n\t                get: function get() {\n\t                  return root._get('/profile/keys/' + keyId);\n\t                },\n\t                remove: function remove() {\n\t                  return _this4._delete('/profile/keys/' + keyId);\n\t                },\n\t                enable: function enable() {\n\t                  return root._put('/profile/keys/' + keyId + '/enable');\n\t                },\n\t                disable: function disable() {\n\t                  return root._put('/profile/keys/' + keyId + '/disable');\n\t                }\n\t              };\n\t            }\n\t          };\n\t        }\n\t      };\n\t    }\n\t\n\t    /* Examples of how to access admin API with this client:\n\t     *\n\t     * List all apps\n\t     *    a.apps().list()\n\t     *\n\t     * Fetch app under name 'planner'\n\t     *    a.apps().app('planner').get()\n\t     *\n\t     * List services under the app 'planner'\n\t     *    a.apps().app('planner').services().list()\n\t     *\n\t     * Delete a rule by ID\n\t     *    a.apps().app('planner').services().service('mdb1').rules().rule('580e6d055b199c221fcb821d').remove()\n\t     *\n\t     */\n\t\n\t  }, {\n\t    key: 'apps',\n\t    value: function apps() {\n\t      var _this5 = this;\n\t\n\t      var root = this;\n\t      return {\n\t        list: function list() {\n\t          return root._get('/apps');\n\t        },\n\t        create: function create(data) {\n\t          return root._post('/apps', data);\n\t        },\n\t        app: function app(appID) {\n\t          return {\n\t            get: function get() {\n\t              return root._get('/apps/' + appID);\n\t            },\n\t            remove: function remove() {\n\t              return root._delete('/apps/' + appID);\n\t            },\n\t\n\t            users: function users() {\n\t              return {\n\t                list: function list(filter) {\n\t                  return _this5._get('/apps/' + appID + '/users', filter);\n\t                },\n\t                user: function user(uid) {\n\t                  return {\n\t                    get: function get() {\n\t                      return _this5._get('/apps/' + appID + '/users/' + uid);\n\t                    },\n\t                    logout: function logout() {\n\t                      return _this5._put('/apps/' + appID + '/users/' + uid + '/logout');\n\t                    }\n\t                  };\n\t                }\n\t              };\n\t            },\n\t\n\t            sandbox: function sandbox() {\n\t              return {\n\t                executePipeline: function executePipeline(data, userId) {\n\t                  return _this5._doAuthed('/apps/' + appID + '/sandbox/pipeline', 'POST', { body: JSON.stringify(data), queryParams: { user_id: userId } });\n\t                }\n\t              };\n\t            },\n\t\n\t            authProviders: function authProviders() {\n\t              return {\n\t                create: function create(data) {\n\t                  return _this5._post('/apps/' + appID + '/authProviders', data);\n\t                },\n\t                list: function list() {\n\t                  return _this5._get('/apps/' + appID + '/authProviders');\n\t                },\n\t                provider: function provider(authType, authName) {\n\t                  return {\n\t                    get: function get() {\n\t                      return _this5._get('/apps/' + appID + '/authProviders/' + authType + '/' + authName);\n\t                    },\n\t                    remove: function remove() {\n\t                      return _this5._delete('/apps/' + appID + '/authProviders/' + authType + '/' + authName);\n\t                    },\n\t                    update: function update(data) {\n\t                      return _this5._post('/apps/' + appID + '/authProviders/' + authType + '/' + authName, data);\n\t                    }\n\t                  };\n\t                }\n\t              };\n\t            },\n\t            variables: function variables() {\n\t              return {\n\t                list: function list() {\n\t                  return _this5._get('/apps/' + appID + '/vars');\n\t                },\n\t                variable: function variable(varName) {\n\t                  return {\n\t                    get: function get() {\n\t                      return _this5._get('/apps/' + appID + '/vars/' + varName);\n\t                    },\n\t                    remove: function remove() {\n\t                      return _this5._delete('/apps/' + appID + '/vars/' + varName);\n\t                    },\n\t                    create: function create(data) {\n\t                      return _this5._post('/apps/' + appID + '/vars/' + varName, data);\n\t                    },\n\t                    update: function update(data) {\n\t                      return _this5._post('/apps/' + appID + '/vars/' + varName, data);\n\t                    }\n\t                  };\n\t                }\n\t              };\n\t            },\n\t            logs: function logs() {\n\t              return {\n\t                get: function get(filter) {\n\t                  return _this5._get('/apps/' + appID + '/logs', filter);\n\t                }\n\t              };\n\t            },\n\t            apiKeys: function apiKeys() {\n\t              return {\n\t                list: function list() {\n\t                  return _this5._get('/apps/' + appID + '/keys');\n\t                },\n\t                create: function create(data) {\n\t                  return _this5._post('/apps/' + appID + '/keys', data);\n\t                },\n\t                apiKey: function apiKey(key) {\n\t                  return {\n\t                    get: function get() {\n\t                      return _this5._get('/apps/' + appID + '/keys/' + key);\n\t                    },\n\t                    remove: function remove() {\n\t                      return _this5._delete('/apps/' + appID + '/keys/' + key);\n\t                    },\n\t                    enable: function enable() {\n\t                      return _this5._put('/apps/' + appID + '/keys/' + key + '/enable');\n\t                    },\n\t                    disable: function disable() {\n\t                      return _this5._put('/apps/' + appID + '/keys/' + key + '/disable');\n\t                    }\n\t                  };\n\t                }\n\t              };\n\t            },\n\t            services: function services() {\n\t              return {\n\t                list: function list() {\n\t                  return _this5._get('/apps/' + appID + '/services');\n\t                },\n\t                create: function create(data) {\n\t                  return _this5._post('/apps/' + appID + '/services', data);\n\t                },\n\t                service: function service(svc) {\n\t                  return {\n\t                    get: function get() {\n\t                      return _this5._get('/apps/' + appID + '/services/' + svc);\n\t                    },\n\t                    update: function update(data) {\n\t                      return _this5._post('/apps/' + appID + '/services/' + svc, data);\n\t                    },\n\t                    remove: function remove() {\n\t                      return _this5._delete('/apps/' + appID + '/services/' + svc);\n\t                    },\n\t                    setConfig: function setConfig(data) {\n\t                      return _this5._post('/apps/' + appID + '/services/' + svc + '/config', data);\n\t                    },\n\t\n\t                    rules: function rules() {\n\t                      return {\n\t                        list: function list() {\n\t                          return _this5._get('/apps/' + appID + '/services/' + svc + '/rules');\n\t                        },\n\t                        create: function create(data) {\n\t                          return _this5._post('/apps/' + appID + '/services/' + svc + '/rules');\n\t                        },\n\t                        rule: function rule(ruleId) {\n\t                          return {\n\t                            get: function get() {\n\t                              return _this5._get('/apps/' + appID + '/services/' + svc + '/rules/' + ruleId);\n\t                            },\n\t                            update: function update(data) {\n\t                              return _this5._post('/apps/' + appID + '/services/' + svc + '/rules/' + ruleId, data);\n\t                            },\n\t                            remove: function remove() {\n\t                              return _this5._delete('/apps/' + appID + '/services/' + svc + '/rules/' + ruleId);\n\t                            }\n\t                          };\n\t                        }\n\t                      };\n\t                    },\n\t\n\t                    triggers: function triggers() {\n\t                      return {\n\t                        list: function list() {\n\t                          return _this5._get('/apps/' + appID + '/services/' + svc + '/triggers');\n\t                        },\n\t                        create: function create(data) {\n\t                          return _this5._post('/apps/' + appID + '/services/' + svc + '/triggers');\n\t                        },\n\t                        trigger: function trigger(triggerId) {\n\t                          return {\n\t                            get: function get() {\n\t                              return _this5._get('/apps/' + appID + '/services/' + svc + '/triggers/' + triggerId);\n\t                            },\n\t                            update: function update(data) {\n\t                              return _this5._post('/apps/' + appID + '/services/' + svc + '/triggers/' + triggerId, data);\n\t                            },\n\t                            remove: function remove() {\n\t                              return _this5._delete('/apps/' + appID + '/services/' + svc + '/triggers/' + triggerId);\n\t                            }\n\t                          };\n\t                        }\n\t                      };\n\t                    }\n\t                  };\n\t                }\n\t              };\n\t            }\n\t          };\n\t        }\n\t      };\n\t    }\n\t  }, {\n\t    key: '_admin',\n\t    value: function _admin() {\n\t      var _this6 = this;\n\t\n\t      return {\n\t        logs: function logs() {\n\t          return {\n\t            get: function get(filter) {\n\t              return _this6._doAuthed('/admin/logs', 'GET', { useRefreshToken: true, queryParams: filter });\n\t            }\n\t          };\n\t        },\n\t        users: function users() {\n\t          return {\n\t            list: function list(filter) {\n\t              return _this6._doAuthed('/admin/users', 'GET', { useRefreshToken: true, queryParams: filter });\n\t            },\n\t            user: function user(uid) {\n\t              return {\n\t                logout: function logout() {\n\t                  return _this6._doAuthed('/admin/users/' + uid + '/logout', 'PUT', { useRefreshToken: true });\n\t                }\n\t              };\n\t            }\n\t          };\n\t        }\n\t      };\n\t    }\n\t  }, {\n\t    key: '_isImpersonatingUser',\n\t    value: function _isImpersonatingUser() {\n\t      return this.client.authManager.isImpersonatingUser();\n\t    }\n\t  }, {\n\t    key: '_startImpersonation',\n\t    value: function _startImpersonation(userId) {\n\t      return this.client.authManager.startImpersonation(this.client, userId);\n\t    }\n\t  }, {\n\t    key: '_stopImpersonation',\n\t    value: function _stopImpersonation(userId) {\n\t      return this.client.authManager.stopImpersonation();\n\t    }\n\t  }]);\n\t\n\t  return Admin;\n\t}();\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global window, fetch */\n\t\n\t/* let authDataStorage;\n\tif(window !== undefined && window.localStorage !== undefined){\n\t  authDataStorage = window.localStorage\n\t}\n\t\n\t*/\n\t\n\tvar _common = __webpack_require__(2);\n\t\n\tvar common = _interopRequireWildcard(_common);\n\t\n\tvar _jsBase = __webpack_require__(3);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar AuthDataStorage = function () {\n\t  function AuthDataStorage() {\n\t    _classCallCheck(this, AuthDataStorage);\n\t\n\t    this._data = {};\n\t  }\n\t\n\t  _createClass(AuthDataStorage, [{\n\t    key: 'setItem',\n\t    value: function setItem(id, val) {\n\t      this._data[id] = String(val);\n\t    }\n\t  }, {\n\t    key: 'getItem',\n\t    value: function getItem(id) {\n\t      return this._data.hasOwnProperty(id) ? this._data[id] : undefined;\n\t    }\n\t  }, {\n\t    key: 'removeItem',\n\t    value: function removeItem(id) {\n\t      return delete this._data[id];\n\t    }\n\t  }, {\n\t    key: 'clear',\n\t    value: function clear() {\n\t      this._data = {};\n\t    }\n\t  }]);\n\t\n\t  return AuthDataStorage;\n\t}();\n\t\n\tvar Auth = function () {\n\t  function Auth(rootUrl) {\n\t    _classCallCheck(this, Auth);\n\t\n\t    this.rootUrl = rootUrl;\n\t    if (typeof window !== 'undefined' && window.localStorage !== undefined) {\n\t      this.authDataStorage = window.localStorage;\n\t    } else {\n\t      this.authDataStorage = new AuthDataStorage();\n\t    }\n\t  }\n\t\n\t  _createClass(Auth, [{\n\t    key: 'pageRootUrl',\n\t    value: function pageRootUrl() {\n\t      return [window.location.protocol, '//', window.location.host, window.location.pathname].join('');\n\t    }\n\t\n\t    // The state we generate is to be used for any kind of request where we will\n\t    // complete an authentication flow via a redirect. We store the generate in\n\t    // a local storage bound to the app's origin. This ensures that any time we\n\t    // receive a redirect, there must be a state parameter and it must match\n\t    // what we ourselves have generated. This state MUST only be sent to\n\t    // a trusted BaaS endpoint in order to preserve its integrity. BaaS will\n\t    // store it in some way on its origin (currently a cookie stored on this client)\n\t    // and use that state at the end of an auth flow as a parameter in the redirect URI.\n\t\n\t  }, {\n\t    key: 'setAccessToken',\n\t    value: function setAccessToken(token) {\n\t      var currAuth = this.get();\n\t      currAuth['accessToken'] = token;\n\t      currAuth['refreshToken'] = this.authDataStorage.getItem(common.REFRESH_TOKEN_KEY);\n\t      this.set(currAuth);\n\t    }\n\t  }, {\n\t    key: 'error',\n\t    value: function error() {\n\t      return this._error;\n\t    }\n\t  }, {\n\t    key: 'handleRedirect',\n\t    value: function handleRedirect() {\n\t      var ourState = this.authDataStorage.getItem(common.STATE_KEY);\n\t      if (typeof window === 'undefined') {\n\t        // This means we're running in some environment other\n\t        // than a browser - so handling a redirect makes no sense here.\n\t        return;\n\t      }\n\t      var redirectFragment = window.location.hash.substring(1);\n\t      var redirectState = common.parseRedirectFragment(redirectFragment, ourState);\n\t      if (redirectState.lastError) {\n\t        console.error('BaasClient: error from redirect: ' + redirectState.lastError);\n\t        this._error = redirectState.lastError;\n\t        window.history.replaceState(null, '', this.pageRootUrl());\n\t        return;\n\t      }\n\t      if (!redirectState.found) {\n\t        return;\n\t      }\n\t      this.authDataStorage.removeItem(common.STATE_KEY);\n\t      if (!redirectState.stateValid) {\n\t        console.error('BaasClient: state values did not match!');\n\t        window.history.replaceState(null, '', this.pageRootUrl());\n\t        return;\n\t      }\n\t      if (!redirectState.ua) {\n\t        console.error('BaasClient: no UA value was returned from redirect!');\n\t        return;\n\t      }\n\t      // If we get here, the state is valid - set auth appropriately.\n\t      this.set(redirectState.ua);\n\t      window.history.replaceState(null, '', this.pageRootUrl());\n\t    }\n\t  }, {\n\t    key: 'getOAuthLoginURL',\n\t    value: function getOAuthLoginURL(providerName, redirectUrl) {\n\t      if (redirectUrl === undefined) {\n\t        redirectUrl = this.pageRootUrl();\n\t      }\n\t      var state = Auth.generateState();\n\t      this.authDataStorage.setItem(common.STATE_KEY, state);\n\t      var result = this.rootUrl + '/oauth2/' + providerName + '?redirect=' + encodeURI(redirectUrl) + '&state=' + state;\n\t      return result;\n\t    }\n\t  }, {\n\t    key: 'anonymousAuth',\n\t    value: function anonymousAuth(cors) {\n\t      var _this = this;\n\t\n\t      var init = {\n\t        method: 'GET',\n\t        headers: {\n\t          'Accept': common.JSONTYPE,\n\t          'Content-Type': common.JSONTYPE\n\t        }\n\t      };\n\t\n\t      // TODO get rid of the cors flag. it should just be on all the time.\n\t      if (cors) {\n\t        init['cors'] = cors;\n\t      }\n\t\n\t      return fetch(this.rootUrl + '/anon/user', init).then(common.checkStatus).then(function (response) {\n\t        return response.json().then(function (json) {\n\t          _this.set(json);\n\t          Promise.resolve();\n\t        });\n\t      });\n\t    }\n\t  }, {\n\t    key: 'apiKeyAuth',\n\t    value: function apiKeyAuth(key) {\n\t      var _this2 = this;\n\t\n\t      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { cors: true };\n\t\n\t      var init = {\n\t        method: 'POST',\n\t        headers: {\n\t          'Accept': common.JSONTYPE,\n\t          'Content-Type': common.JSONTYPE\n\t        },\n\t        body: JSON.stringify({ 'key': key })\n\t      };\n\t\n\t      if (options && options.cors === false) {\n\t        init['cors'] = false;\n\t      } else {\n\t        init['cors'] = true;\n\t      }\n\t\n\t      return fetch(this.rootUrl + '/api/key', init).then(common.checkStatus).then(function (response) {\n\t        return response.json().then(function (json) {\n\t          _this2.set(json);\n\t          return Promise.resolve();\n\t        });\n\t      });\n\t    }\n\t  }, {\n\t    key: 'localAuth',\n\t    value: function localAuth(username, password) {\n\t      var _this3 = this;\n\t\n\t      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { cors: true };\n\t\n\t      var init = {\n\t        method: 'POST',\n\t        headers: {\n\t          'Accept': common.JSONTYPE,\n\t          'Content-Type': common.JSONTYPE\n\t        },\n\t        body: JSON.stringify({ 'username': username, 'password': password })\n\t      };\n\t\n\t      if (options && options.cors === false) {\n\t        init['cors'] = false;\n\t      } else {\n\t        init['cors'] = true;\n\t      }\n\t\n\t      return fetch(this.rootUrl + '/local/userpass', init).then(common.checkStatus).then(function (response) {\n\t        return response.json().then(function (json) {\n\t          _this3.set(json);\n\t          return Promise.resolve();\n\t        });\n\t      });\n\t    }\n\t  }, {\n\t    key: 'clear',\n\t    value: function clear() {\n\t      this.authDataStorage.removeItem(common.USER_AUTH_KEY);\n\t      this.authDataStorage.removeItem(common.REFRESH_TOKEN_KEY);\n\t      this.clearImpersonation();\n\t    }\n\t  }, {\n\t    key: 'getRefreshToken',\n\t    value: function getRefreshToken() {\n\t      return this.authDataStorage.getItem(common.REFRESH_TOKEN_KEY);\n\t    }\n\t  }, {\n\t    key: 'set',\n\t    value: function set(json) {\n\t      var rt = json['refreshToken'];\n\t      delete json['refreshToken'];\n\t\n\t      console.log('basfsaf', _jsBase.Base64);\n\t      var c = _jsBase.Base64.encode;\n\t      this.authDataStorage.setItem(common.USER_AUTH_KEY, c(JSON.stringify(json)));\n\t      this.authDataStorage.setItem(common.REFRESH_TOKEN_KEY, rt);\n\t    }\n\t  }, {\n\t    key: 'get',\n\t    value: function get() {\n\t      if (this.authDataStorage.getItem(common.USER_AUTH_KEY) === null) {\n\t        return null;\n\t      }\n\t      return JSON.parse(_jsBase.Base64.decode(this.authDataStorage.getItem(common.USER_AUTH_KEY)));\n\t    }\n\t  }, {\n\t    key: 'authedId',\n\t    value: function authedId() {\n\t      var id = ((this.get() || {}).user || {})._id;\n\t      if (id) {\n\t        return { '$oid': id };\n\t      }\n\t    }\n\t  }, {\n\t    key: 'isImpersonatingUser',\n\t    value: function isImpersonatingUser() {\n\t      return this.authDataStorage.getItem(common.IMPERSONATION_ACTIVE_KEY) === 'true';\n\t    }\n\t  }, {\n\t    key: 'refreshImpersonation',\n\t    value: function refreshImpersonation(client) {\n\t      var _this4 = this;\n\t\n\t      var userId = this.authDataStorage.getItem(common.IMPERSONATION_USER_KEY);\n\t      return client._doAuthed('/admin/users/' + userId + '/impersonate', 'POST', { refreshOnFailure: false, useRefreshToken: true }).then(function (response) {\n\t        return response.json().then(function (json) {\n\t          json['refreshToken'] = _this4.authDataStorage.getItem(common.REFRESH_TOKEN_KEY);\n\t          _this4.set(json);\n\t          return Promise.resolve();\n\t        });\n\t      }).catch(function (e) {\n\t        _this4.stopImpersonation();\n\t        throw e;\n\t      });\n\t    }\n\t  }, {\n\t    key: 'startImpersonation',\n\t    value: function startImpersonation(client, userId) {\n\t      if (this.get() === null) {\n\t        return Promise.reject(new common.BaasError('Must auth first'));\n\t      }\n\t      if (this.isImpersonatingUser()) {\n\t        throw new common.BaasError('Already impersonating a user');\n\t      }\n\t      this.authDataStorage.setItem(common.IMPERSONATION_ACTIVE_KEY, 'true');\n\t      this.authDataStorage.setItem(common.IMPERSONATION_USER_KEY, userId);\n\t\n\t      var realUserAuth = JSON.parse(_jsBase.Base64.decode(this.authDataStorage.getItem(common.USER_AUTH_KEY)));\n\t      realUserAuth['refreshToken'] = this.authDataStorage.getItem(common.REFRESH_TOKEN_KEY);\n\t      this.authDataStorage.setItem(common.IMPERSONATION_REAL_USER_AUTH_KEY, _jsBase.Base64.encode(JSON.stringify(realUserAuth)));\n\t      return this.refreshImpersonation(client);\n\t    }\n\t  }, {\n\t    key: 'stopImpersonation',\n\t    value: function stopImpersonation() {\n\t      var root = this;\n\t      return new Promise(function (resolve, reject) {\n\t        if (!root.isImpersonatingUser()) {\n\t          throw new common.BaasError('Not impersonating a user');\n\t        }\n\t        var realUserAuth = JSON.parse(_jsBase.Base64.decode(this.authDataStorage.getItem(common.IMPERSONATION_REAL_USER_AUTH_KEY)));\n\t        root.set(realUserAuth);\n\t        root.clearImpersonation();\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'clearImpersonation',\n\t    value: function clearImpersonation() {\n\t      this.authDataStorage.removeItem(common.IMPERSONATION_ACTIVE_KEY);\n\t      this.authDataStorage.removeItem(common.IMPERSONATION_USER_KEY);\n\t      this.authDataStorage.removeItem(common.IMPERSONATION_REAL_USER_AUTH_KEY);\n\t    }\n\t  }], [{\n\t    key: 'generateState',\n\t    value: function generateState() {\n\t      var alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\t      var state = '';\n\t      var stateLength = 64;\n\t      for (var i = 0; i < stateLength; i++) {\n\t        var pos = Math.floor(Math.random() * alpha.length);\n\t        state += alpha.substring(pos, pos + 1);\n\t      }\n\t      return state;\n\t    }\n\t  }]);\n\t\n\t  return Auth;\n\t}();\n\t\n\texports.default = Auth;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar JSONTYPE = exports.JSONTYPE = 'application/json';\n\tvar USER_AUTH_KEY = exports.USER_AUTH_KEY = '_baas_ua';\n\tvar REFRESH_TOKEN_KEY = exports.REFRESH_TOKEN_KEY = '_baas_rt';\n\tvar STATE_KEY = exports.STATE_KEY = '_baas_state';\n\tvar BAAS_ERROR_KEY = exports.BAAS_ERROR_KEY = '_baas_error';\n\tvar BAAS_LINK_KEY = exports.BAAS_LINK_KEY = '_baas_link';\n\tvar IMPERSONATION_ACTIVE_KEY = exports.IMPERSONATION_ACTIVE_KEY = '_baas_impers_active';\n\tvar IMPERSONATION_USER_KEY = exports.IMPERSONATION_USER_KEY = '_baas_impers_user';\n\tvar IMPERSONATION_REAL_USER_AUTH_KEY = exports.IMPERSONATION_REAL_USER_AUTH_KEY = '_baas_impers_real_ua';\n\t\n\tvar DEFAULT_BAAS_SERVER_URL = exports.DEFAULT_BAAS_SERVER_URL = 'https://baas-dev.10gen.cc';\n\t\n\tvar checkStatus = exports.checkStatus = function checkStatus(response) {\n\t  if (response.status >= 200 && response.status < 300) {\n\t    return response;\n\t  } else {\n\t    var error = new Error(response.statusText);\n\t    error.response = response;\n\t    throw error;\n\t  }\n\t};\n\t\n\tvar parseRedirectFragment = exports.parseRedirectFragment = function parseRedirectFragment(fragment, ourState) {\n\t  // After being redirected from oauth, the URL will look like:\n\t  // https://todo.examples.baas-dev.10gen.cc/#_baas_state=...&_baas_ua=...\n\t  // This function parses out baas-specific tokens from the fragment and\n\t  // builds an object describing the result.\n\t  var vars = fragment.split('&');\n\t  var result = { ua: null, found: false, stateValid: false, lastError: null };\n\t  var shouldBreak = false;\n\t  var _iteratorNormalCompletion = true;\n\t  var _didIteratorError = false;\n\t  var _iteratorError = undefined;\n\t\n\t  try {\n\t    for (var _iterator = vars[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t      var pair = _step.value;\n\t\n\t      var pairParts = pair.split('=');\n\t      var pairKey = decodeURIComponent(pairParts[0]);\n\t      switch (pairKey) {\n\t        case BAAS_ERROR_KEY:\n\t          result.lastError = decodeURIComponent(pairParts[1]);\n\t          result.found = true;\n\t          shouldBreak = true;\n\t          break;\n\t        case USER_AUTH_KEY:\n\t          result.ua = JSON.parse(window.atob(decodeURIComponent(pairParts[1])));\n\t          result.found = true;\n\t          continue;\n\t        case BAAS_LINK_KEY:\n\t          result.found = true;\n\t          continue;\n\t        case STATE_KEY:\n\t          result.found = true;\n\t          var theirState = decodeURIComponent(pairParts[1]);\n\t          if (ourState && ourState === theirState) {\n\t            result.stateValid = true;\n\t          }\n\t      }\n\t      if (shouldBreak) {\n\t        break;\n\t      }\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError = true;\n\t    _iteratorError = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion && _iterator.return) {\n\t        _iterator.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError) {\n\t        throw _iteratorError;\n\t      }\n\t    }\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\tvar BaasError = exports.BaasError = function (_Error) {\n\t  _inherits(BaasError, _Error);\n\t\n\t  function BaasError(message, code) {\n\t    _classCallCheck(this, BaasError);\n\t\n\t    var _this = _possibleConstructorReturn(this, (BaasError.__proto__ || Object.getPrototypeOf(BaasError)).call(this, message));\n\t\n\t    _this.name = 'BaasError';\n\t    _this.message = message;\n\t    if (code !== undefined) {\n\t      _this.code = code;\n\t    }\n\t    if (typeof Error.captureStackTrace === 'function') {\n\t      Error.captureStackTrace(_this, _this.constructor);\n\t    } else {\n\t      _this.stack = new Error(message).stack;\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  return BaasError;\n\t}(Error);\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $\n\t *\n\t *  Licensed under the MIT license.\n\t *    http://opensource.org/licenses/mit-license\n\t *\n\t *  References:\n\t *    http://en.wikipedia.org/wiki/Base64\n\t */\n\t\n\t(function(global) {\n\t    'use strict';\n\t    // existing version for noConflict()\n\t    var _Base64 = global.Base64;\n\t    var version = \"2.1.9\";\n\t    // if node.js, we use Buffer\n\t    var buffer;\n\t    if (typeof module !== 'undefined' && module.exports) {\n\t        try {\n\t            buffer = __webpack_require__(4).Buffer;\n\t        } catch (err) {}\n\t    }\n\t    // constants\n\t    var b64chars\n\t        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t    var b64tab = function(bin) {\n\t        var t = {};\n\t        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;\n\t        return t;\n\t    }(b64chars);\n\t    var fromCharCode = String.fromCharCode;\n\t    // encoder stuff\n\t    var cb_utob = function(c) {\n\t        if (c.length < 2) {\n\t            var cc = c.charCodeAt(0);\n\t            return cc < 0x80 ? c\n\t                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))\n\t                                + fromCharCode(0x80 | (cc & 0x3f)))\n\t                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))\n\t                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))\n\t                   + fromCharCode(0x80 | ( cc         & 0x3f)));\n\t        } else {\n\t            var cc = 0x10000\n\t                + (c.charCodeAt(0) - 0xD800) * 0x400\n\t                + (c.charCodeAt(1) - 0xDC00);\n\t            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))\n\t                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))\n\t                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))\n\t                    + fromCharCode(0x80 | ( cc         & 0x3f)));\n\t        }\n\t    };\n\t    var re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n\t    var utob = function(u) {\n\t        return u.replace(re_utob, cb_utob);\n\t    };\n\t    var cb_encode = function(ccc) {\n\t        var padlen = [0, 2, 1][ccc.length % 3],\n\t        ord = ccc.charCodeAt(0) << 16\n\t            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)\n\t            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),\n\t        chars = [\n\t            b64chars.charAt( ord >>> 18),\n\t            b64chars.charAt((ord >>> 12) & 63),\n\t            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),\n\t            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)\n\t        ];\n\t        return chars.join('');\n\t    };\n\t    var btoa = global.btoa ? function(b) {\n\t        return global.btoa(b);\n\t    } : function(b) {\n\t        return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n\t    };\n\t    var _encode = buffer ? function (u) {\n\t        return (u.constructor === buffer.constructor ? u : new buffer(u))\n\t        .toString('base64')\n\t    }\n\t    : function (u) { return btoa(utob(u)) }\n\t    ;\n\t    var encode = function(u, urisafe) {\n\t        return !urisafe\n\t            ? _encode(String(u))\n\t            : _encode(String(u)).replace(/[+\\/]/g, function(m0) {\n\t                return m0 == '+' ? '-' : '_';\n\t            }).replace(/=/g, '');\n\t    };\n\t    var encodeURI = function(u) { return encode(u, true) };\n\t    // decoder stuff\n\t    var re_btou = new RegExp([\n\t        '[\\xC0-\\xDF][\\x80-\\xBF]',\n\t        '[\\xE0-\\xEF][\\x80-\\xBF]{2}',\n\t        '[\\xF0-\\xF7][\\x80-\\xBF]{3}'\n\t    ].join('|'), 'g');\n\t    var cb_btou = function(cccc) {\n\t        switch(cccc.length) {\n\t        case 4:\n\t            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n\t                |    ((0x3f & cccc.charCodeAt(1)) << 12)\n\t                |    ((0x3f & cccc.charCodeAt(2)) <<  6)\n\t                |     (0x3f & cccc.charCodeAt(3)),\n\t            offset = cp - 0x10000;\n\t            return (fromCharCode((offset  >>> 10) + 0xD800)\n\t                    + fromCharCode((offset & 0x3FF) + 0xDC00));\n\t        case 3:\n\t            return fromCharCode(\n\t                ((0x0f & cccc.charCodeAt(0)) << 12)\n\t                    | ((0x3f & cccc.charCodeAt(1)) << 6)\n\t                    |  (0x3f & cccc.charCodeAt(2))\n\t            );\n\t        default:\n\t            return  fromCharCode(\n\t                ((0x1f & cccc.charCodeAt(0)) << 6)\n\t                    |  (0x3f & cccc.charCodeAt(1))\n\t            );\n\t        }\n\t    };\n\t    var btou = function(b) {\n\t        return b.replace(re_btou, cb_btou);\n\t    };\n\t    var cb_decode = function(cccc) {\n\t        var len = cccc.length,\n\t        padlen = len % 4,\n\t        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)\n\t            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)\n\t            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)\n\t            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),\n\t        chars = [\n\t            fromCharCode( n >>> 16),\n\t            fromCharCode((n >>>  8) & 0xff),\n\t            fromCharCode( n         & 0xff)\n\t        ];\n\t        chars.length -= [0, 0, 2, 1][padlen];\n\t        return chars.join('');\n\t    };\n\t    var atob = global.atob ? function(a) {\n\t        return global.atob(a);\n\t    } : function(a){\n\t        return a.replace(/[\\s\\S]{1,4}/g, cb_decode);\n\t    };\n\t    var _decode = buffer ? function(a) {\n\t        return (a.constructor === buffer.constructor\n\t                ? a : new buffer(a, 'base64')).toString();\n\t    }\n\t    : function(a) { return btou(atob(a)) };\n\t    var decode = function(a){\n\t        return _decode(\n\t            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })\n\t                .replace(/[^A-Za-z0-9\\+\\/]/g, '')\n\t        );\n\t    };\n\t    var noConflict = function() {\n\t        var Base64 = global.Base64;\n\t        global.Base64 = _Base64;\n\t        return Base64;\n\t    };\n\t    // export Base64\n\t    global.Base64 = {\n\t        VERSION: version,\n\t        atob: atob,\n\t        btoa: btoa,\n\t        fromBase64: decode,\n\t        toBase64: encode,\n\t        utob: utob,\n\t        encode: encode,\n\t        encodeURI: encodeURI,\n\t        btou: btou,\n\t        decode: decode,\n\t        noConflict: noConflict\n\t    };\n\t    // if ES5 is available, make Base64.extendString() available\n\t    if (typeof Object.defineProperty === 'function') {\n\t        var noEnum = function(v){\n\t            return {value:v,enumerable:false,writable:true,configurable:true};\n\t        };\n\t        global.Base64.extendString = function () {\n\t            Object.defineProperty(\n\t                String.prototype, 'fromBase64', noEnum(function () {\n\t                    return decode(this)\n\t                }));\n\t            Object.defineProperty(\n\t                String.prototype, 'toBase64', noEnum(function (urisafe) {\n\t                    return encode(this, urisafe)\n\t                }));\n\t            Object.defineProperty(\n\t                String.prototype, 'toBase64URI', noEnum(function () {\n\t                    return encode(this, true)\n\t                }));\n\t        };\n\t    }\n\t    // that's it!\n\t    if (global['Meteor']) {\n\t       Base64 = global.Base64; // for normal export in Meteor.js\n\t    }\n\t})(this);\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t/* eslint-disable no-proto */\n\t\n\t'use strict'\n\t\n\tvar base64 = __webpack_require__(5)\n\tvar ieee754 = __webpack_require__(6)\n\tvar isArray = __webpack_require__(7)\n\t\n\texports.Buffer = Buffer\n\texports.SlowBuffer = SlowBuffer\n\texports.INSPECT_MAX_BYTES = 50\n\t\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\t\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global.TYPED_ARRAY_SUPPORT\n\t  : typedArraySupport()\n\t\n\t/*\n\t * Export kMaxLength after typed array support is determined.\n\t */\n\texports.kMaxLength = kMaxLength()\n\t\n\tfunction typedArraySupport () {\n\t  try {\n\t    var arr = new Uint8Array(1)\n\t    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n\t    return arr.foo() === 42 && // typed array instances can be augmented\n\t        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n\t        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction kMaxLength () {\n\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\t\n\tfunction createBuffer (that, length) {\n\t  if (kMaxLength() < length) {\n\t    throw new RangeError('Invalid typed array length')\n\t  }\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = new Uint8Array(length)\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    if (that === null) {\n\t      that = new Buffer(length)\n\t    }\n\t    that.length = length\n\t  }\n\t\n\t  return that\n\t}\n\t\n\t/**\n\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t * returns a single octet.\n\t *\n\t * The `Uint8Array` prototype remains unmodified.\n\t */\n\t\n\tfunction Buffer (arg, encodingOrOffset, length) {\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n\t    return new Buffer(arg, encodingOrOffset, length)\n\t  }\n\t\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    if (typeof encodingOrOffset === 'string') {\n\t      throw new Error(\n\t        'If encoding is specified then the first argument must be a string'\n\t      )\n\t    }\n\t    return allocUnsafe(this, arg)\n\t  }\n\t  return from(this, arg, encodingOrOffset, length)\n\t}\n\t\n\tBuffer.poolSize = 8192 // not used by this implementation\n\t\n\t// TODO: Legacy, not needed anymore. Remove in next major version.\n\tBuffer._augment = function (arr) {\n\t  arr.__proto__ = Buffer.prototype\n\t  return arr\n\t}\n\t\n\tfunction from (that, value, encodingOrOffset, length) {\n\t  if (typeof value === 'number') {\n\t    throw new TypeError('\"value\" argument must not be a number')\n\t  }\n\t\n\t  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n\t    return fromArrayBuffer(that, value, encodingOrOffset, length)\n\t  }\n\t\n\t  if (typeof value === 'string') {\n\t    return fromString(that, value, encodingOrOffset)\n\t  }\n\t\n\t  return fromObject(that, value)\n\t}\n\t\n\t/**\n\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t * if value is a number.\n\t * Buffer.from(str[, encoding])\n\t * Buffer.from(array)\n\t * Buffer.from(buffer)\n\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t **/\n\tBuffer.from = function (value, encodingOrOffset, length) {\n\t  return from(null, value, encodingOrOffset, length)\n\t}\n\t\n\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t  Buffer.prototype.__proto__ = Uint8Array.prototype\n\t  Buffer.__proto__ = Uint8Array\n\t  if (typeof Symbol !== 'undefined' && Symbol.species &&\n\t      Buffer[Symbol.species] === Buffer) {\n\t    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n\t    Object.defineProperty(Buffer, Symbol.species, {\n\t      value: null,\n\t      configurable: true\n\t    })\n\t  }\n\t}\n\t\n\tfunction assertSize (size) {\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('\"size\" argument must be a number')\n\t  } else if (size < 0) {\n\t    throw new RangeError('\"size\" argument must not be negative')\n\t  }\n\t}\n\t\n\tfunction alloc (that, size, fill, encoding) {\n\t  assertSize(size)\n\t  if (size <= 0) {\n\t    return createBuffer(that, size)\n\t  }\n\t  if (fill !== undefined) {\n\t    // Only pay attention to encoding if it's a string. This\n\t    // prevents accidentally sending in a number that would\n\t    // be interpretted as a start offset.\n\t    return typeof encoding === 'string'\n\t      ? createBuffer(that, size).fill(fill, encoding)\n\t      : createBuffer(that, size).fill(fill)\n\t  }\n\t  return createBuffer(that, size)\n\t}\n\t\n\t/**\n\t * Creates a new filled Buffer instance.\n\t * alloc(size[, fill[, encoding]])\n\t **/\n\tBuffer.alloc = function (size, fill, encoding) {\n\t  return alloc(null, size, fill, encoding)\n\t}\n\t\n\tfunction allocUnsafe (that, size) {\n\t  assertSize(size)\n\t  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < size; ++i) {\n\t      that[i] = 0\n\t    }\n\t  }\n\t  return that\n\t}\n\t\n\t/**\n\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t * */\n\tBuffer.allocUnsafe = function (size) {\n\t  return allocUnsafe(null, size)\n\t}\n\t/**\n\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t */\n\tBuffer.allocUnsafeSlow = function (size) {\n\t  return allocUnsafe(null, size)\n\t}\n\t\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') {\n\t    encoding = 'utf8'\n\t  }\n\t\n\t  if (!Buffer.isEncoding(encoding)) {\n\t    throw new TypeError('\"encoding\" must be a valid string encoding')\n\t  }\n\t\n\t  var length = byteLength(string, encoding) | 0\n\t  that = createBuffer(that, length)\n\t\n\t  var actual = that.write(string, encoding)\n\t\n\t  if (actual !== length) {\n\t    // Writing a hex string, for example, that contains invalid characters will\n\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t    // 'abxxcd' will be treated as 'ab')\n\t    that = that.slice(0, actual)\n\t  }\n\t\n\t  return that\n\t}\n\t\n\tfunction fromArrayLike (that, array) {\n\t  var length = array.length < 0 ? 0 : checked(array.length) | 0\n\t  that = createBuffer(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayBuffer (that, array, byteOffset, length) {\n\t  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\t\n\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t    throw new RangeError('\\'offset\\' is out of bounds')\n\t  }\n\t\n\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t    throw new RangeError('\\'length\\' is out of bounds')\n\t  }\n\t\n\t  if (byteOffset === undefined && length === undefined) {\n\t    array = new Uint8Array(array)\n\t  } else if (length === undefined) {\n\t    array = new Uint8Array(array, byteOffset)\n\t  } else {\n\t    array = new Uint8Array(array, byteOffset, length)\n\t  }\n\t\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = array\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromArrayLike(that, array)\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromObject (that, obj) {\n\t  if (Buffer.isBuffer(obj)) {\n\t    var len = checked(obj.length) | 0\n\t    that = createBuffer(that, len)\n\t\n\t    if (that.length === 0) {\n\t      return that\n\t    }\n\t\n\t    obj.copy(that, 0, 0, len)\n\t    return that\n\t  }\n\t\n\t  if (obj) {\n\t    if ((typeof ArrayBuffer !== 'undefined' &&\n\t        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n\t      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n\t        return createBuffer(that, 0)\n\t      }\n\t      return fromArrayLike(that, obj)\n\t    }\n\t\n\t    if (obj.type === 'Buffer' && isArray(obj.data)) {\n\t      return fromArrayLike(that, obj.data)\n\t    }\n\t  }\n\t\n\t  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n\t}\n\t\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength()` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\t\n\tfunction SlowBuffer (length) {\n\t  if (+length != length) { // eslint-disable-line eqeqeq\n\t    length = 0\n\t  }\n\t  return Buffer.alloc(+length)\n\t}\n\t\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\t\n\tBuffer.compare = function compare (a, b) {\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\t\n\t  if (a === b) return 0\n\t\n\t  var x = a.length\n\t  var y = b.length\n\t\n\t  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n\t    if (a[i] !== b[i]) {\n\t      x = a[i]\n\t      y = b[i]\n\t      break\n\t    }\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'latin1':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t}\n\t\n\tBuffer.concat = function concat (list, length) {\n\t  if (!isArray(list)) {\n\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t  }\n\t\n\t  if (list.length === 0) {\n\t    return Buffer.alloc(0)\n\t  }\n\t\n\t  var i\n\t  if (length === undefined) {\n\t    length = 0\n\t    for (i = 0; i < list.length; ++i) {\n\t      length += list[i].length\n\t    }\n\t  }\n\t\n\t  var buffer = Buffer.allocUnsafe(length)\n\t  var pos = 0\n\t  for (i = 0; i < list.length; ++i) {\n\t    var buf = list[i]\n\t    if (!Buffer.isBuffer(buf)) {\n\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t    }\n\t    buf.copy(buffer, pos)\n\t    pos += buf.length\n\t  }\n\t  return buffer\n\t}\n\t\n\tfunction byteLength (string, encoding) {\n\t  if (Buffer.isBuffer(string)) {\n\t    return string.length\n\t  }\n\t  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n\t      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n\t    return string.byteLength\n\t  }\n\t  if (typeof string !== 'string') {\n\t    string = '' + string\n\t  }\n\t\n\t  var len = string.length\n\t  if (len === 0) return 0\n\t\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t      case undefined:\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength\n\t\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false\n\t\n\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t  // property of a typed array.\n\t\n\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t  // to their upper/lower bounds if the value passed is out of range.\n\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t  if (start === undefined || start < 0) {\n\t    start = 0\n\t  }\n\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t  // coercion fail below.\n\t  if (start > this.length) {\n\t    return ''\n\t  }\n\t\n\t  if (end === undefined || end > this.length) {\n\t    end = this.length\n\t  }\n\t\n\t  if (end <= 0) {\n\t    return ''\n\t  }\n\t\n\t  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\t  end >>>= 0\n\t  start >>>= 0\n\t\n\t  if (end <= start) {\n\t    return ''\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\t\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\t\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Slice(this, start, end)\n\t\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\t// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n\t// Buffer instances.\n\tBuffer.prototype._isBuffer = true\n\t\n\tfunction swap (b, n, m) {\n\t  var i = b[n]\n\t  b[n] = b[m]\n\t  b[m] = i\n\t}\n\t\n\tBuffer.prototype.swap16 = function swap16 () {\n\t  var len = this.length\n\t  if (len % 2 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 2) {\n\t    swap(this, i, i + 1)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.swap32 = function swap32 () {\n\t  var len = this.length\n\t  if (len % 4 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 4) {\n\t    swap(this, i, i + 3)\n\t    swap(this, i + 1, i + 2)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.swap64 = function swap64 () {\n\t  var len = this.length\n\t  if (len % 8 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 8) {\n\t    swap(this, i, i + 7)\n\t    swap(this, i + 1, i + 6)\n\t    swap(this, i + 2, i + 5)\n\t    swap(this, i + 3, i + 4)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.toString = function toString () {\n\t  var length = this.length | 0\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t}\n\t\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t}\n\t\n\tBuffer.prototype.inspect = function inspect () {\n\t  var str = ''\n\t  var max = exports.INSPECT_MAX_BYTES\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n\t    if (this.length > max) str += ' ... '\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t}\n\t\n\tBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t  if (!Buffer.isBuffer(target)) {\n\t    throw new TypeError('Argument must be a Buffer')\n\t  }\n\t\n\t  if (start === undefined) {\n\t    start = 0\n\t  }\n\t  if (end === undefined) {\n\t    end = target ? target.length : 0\n\t  }\n\t  if (thisStart === undefined) {\n\t    thisStart = 0\n\t  }\n\t  if (thisEnd === undefined) {\n\t    thisEnd = this.length\n\t  }\n\t\n\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t    throw new RangeError('out of range index')\n\t  }\n\t\n\t  if (thisStart >= thisEnd && start >= end) {\n\t    return 0\n\t  }\n\t  if (thisStart >= thisEnd) {\n\t    return -1\n\t  }\n\t  if (start >= end) {\n\t    return 1\n\t  }\n\t\n\t  start >>>= 0\n\t  end >>>= 0\n\t  thisStart >>>= 0\n\t  thisEnd >>>= 0\n\t\n\t  if (this === target) return 0\n\t\n\t  var x = thisEnd - thisStart\n\t  var y = end - start\n\t  var len = Math.min(x, y)\n\t\n\t  var thisCopy = this.slice(thisStart, thisEnd)\n\t  var targetCopy = target.slice(start, end)\n\t\n\t  for (var i = 0; i < len; ++i) {\n\t    if (thisCopy[i] !== targetCopy[i]) {\n\t      x = thisCopy[i]\n\t      y = targetCopy[i]\n\t      break\n\t    }\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t//\n\t// Arguments:\n\t// - buffer - a Buffer to search\n\t// - val - a string, Buffer, or number\n\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t// - encoding - an optional encoding, relevant is val is a string\n\t// - dir - true for indexOf, false for lastIndexOf\n\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t  // Empty buffer means no match\n\t  if (buffer.length === 0) return -1\n\t\n\t  // Normalize byteOffset\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset\n\t    byteOffset = 0\n\t  } else if (byteOffset > 0x7fffffff) {\n\t    byteOffset = 0x7fffffff\n\t  } else if (byteOffset < -0x80000000) {\n\t    byteOffset = -0x80000000\n\t  }\n\t  byteOffset = +byteOffset  // Coerce to Number.\n\t  if (isNaN(byteOffset)) {\n\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t    byteOffset = dir ? 0 : (buffer.length - 1)\n\t  }\n\t\n\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n\t  if (byteOffset >= buffer.length) {\n\t    if (dir) return -1\n\t    else byteOffset = buffer.length - 1\n\t  } else if (byteOffset < 0) {\n\t    if (dir) byteOffset = 0\n\t    else return -1\n\t  }\n\t\n\t  // Normalize val\n\t  if (typeof val === 'string') {\n\t    val = Buffer.from(val, encoding)\n\t  }\n\t\n\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t  if (Buffer.isBuffer(val)) {\n\t    // Special case: looking for empty string/buffer always fails\n\t    if (val.length === 0) {\n\t      return -1\n\t    }\n\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t  } else if (typeof val === 'number') {\n\t    val = val & 0xFF // Search for a byte value [0-255]\n\t    if (Buffer.TYPED_ARRAY_SUPPORT &&\n\t        typeof Uint8Array.prototype.indexOf === 'function') {\n\t      if (dir) {\n\t        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t      } else {\n\t        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t      }\n\t    }\n\t    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n\t  }\n\t\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\t\n\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t  var indexSize = 1\n\t  var arrLength = arr.length\n\t  var valLength = val.length\n\t\n\t  if (encoding !== undefined) {\n\t    encoding = String(encoding).toLowerCase()\n\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t      if (arr.length < 2 || val.length < 2) {\n\t        return -1\n\t      }\n\t      indexSize = 2\n\t      arrLength /= 2\n\t      valLength /= 2\n\t      byteOffset /= 2\n\t    }\n\t  }\n\t\n\t  function read (buf, i) {\n\t    if (indexSize === 1) {\n\t      return buf[i]\n\t    } else {\n\t      return buf.readUInt16BE(i * indexSize)\n\t    }\n\t  }\n\t\n\t  var i\n\t  if (dir) {\n\t    var foundIndex = -1\n\t    for (i = byteOffset; i < arrLength; i++) {\n\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t        if (foundIndex === -1) foundIndex = i\n\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex\n\t        foundIndex = -1\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n\t    for (i = byteOffset; i >= 0; i--) {\n\t      var found = true\n\t      for (var j = 0; j < valLength; j++) {\n\t        if (read(arr, i + j) !== read(val, j)) {\n\t          found = false\n\t          break\n\t        }\n\t      }\n\t      if (found) return i\n\t    }\n\t  }\n\t\n\t  return -1\n\t}\n\t\n\tBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t}\n\t\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t}\n\t\n\tBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t}\n\t\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0\n\t  var remaining = buf.length - offset\n\t  if (!length) {\n\t    length = remaining\n\t  } else {\n\t    length = Number(length)\n\t    if (length > remaining) {\n\t      length = remaining\n\t    }\n\t  }\n\t\n\t  // must be an even number of digits\n\t  var strLen = string.length\n\t  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\t\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2\n\t  }\n\t  for (var i = 0; i < length; ++i) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16)\n\t    if (isNaN(parsed)) return i\n\t    buf[offset + i] = parsed\n\t  }\n\t  return i\n\t}\n\t\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction latin1Write (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\t\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8'\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0\n\t    if (isFinite(length)) {\n\t      length = length | 0\n\t      if (encoding === undefined) encoding = 'utf8'\n\t    } else {\n\t      encoding = length\n\t      length = undefined\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    throw new Error(\n\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t    )\n\t  }\n\t\n\t  var remaining = this.length - offset\n\t  if (length === undefined || length > remaining) length = remaining\n\t\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\t\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\t\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Write(this, string, offset, length)\n\t\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t}\n\t\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\t\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end)\n\t  var res = []\n\t\n\t  var i = start\n\t  while (i < end) {\n\t    var firstByte = buf[i]\n\t    var codePoint = null\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1\n\t\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint\n\t\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1]\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          fourthByte = buf[i + 3]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t      }\n\t    }\n\t\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD\n\t      bytesPerSequence = 1\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n\t      codePoint = 0xDC00 | codePoint & 0x3FF\n\t    }\n\t\n\t    res.push(codePoint)\n\t    i += bytesPerSequence\n\t  }\n\t\n\t  return decodeCodePointsArray(res)\n\t}\n\t\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000\n\t\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\t\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = ''\n\t  var i = 0\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    )\n\t  }\n\t  return res\n\t}\n\t\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F)\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction latin1Slice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i])\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length\n\t\n\t  if (!start || start < 0) start = 0\n\t  if (!end || end < 0 || end > len) end = len\n\t\n\t  var out = ''\n\t  for (var i = start; i < end; ++i) {\n\t    out += toHex(buf[i])\n\t  }\n\t  return out\n\t}\n\t\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end)\n\t  var res = ''\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n\t  }\n\t  return res\n\t}\n\t\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  var len = this.length\n\t  start = ~~start\n\t  end = end === undefined ? len : ~~end\n\t\n\t  if (start < 0) {\n\t    start += len\n\t    if (start < 0) start = 0\n\t  } else if (start > len) {\n\t    start = len\n\t  }\n\t\n\t  if (end < 0) {\n\t    end += len\n\t    if (end < 0) end = 0\n\t  } else if (end > len) {\n\t    end = len\n\t  }\n\t\n\t  if (end < start) end = start\n\t\n\t  var newBuf\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = this.subarray(start, end)\n\t    newBuf.__proto__ = Buffer.prototype\n\t  } else {\n\t    var sliceLen = end - start\n\t    newBuf = new Buffer(sliceLen, undefined)\n\t    for (var i = 0; i < sliceLen; ++i) {\n\t      newBuf[i] = this[i + start]\n\t    }\n\t  }\n\t\n\t  return newBuf\n\t}\n\t\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\t\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length)\n\t  }\n\t\n\t  var val = this[offset + --byteLength]\n\t  var mul = 1\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  return this[offset]\n\t}\n\t\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return this[offset] | (this[offset + 1] << 8)\n\t}\n\t\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return (this[offset] << 8) | this[offset + 1]\n\t}\n\t\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t}\n\t\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var i = byteLength\n\t  var mul = 1\n\t  var val = this[offset + --i]\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t}\n\t\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset] | (this[offset + 1] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset + 1] | (this[offset] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t}\n\t\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, true, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, false, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, true, 52, 8)\n\t}\n\t\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, false, 52, 8)\n\t}\n\t\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t}\n\t\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t  }\n\t\n\t  var mul = 1\n\t  var i = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = 0\n\t  var mul = 1\n\t  var sub = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t      sub = 1\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  var sub = 0\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t      sub = 1\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  if (value < 0) value = 0xff + value + 1\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 3] = (value >>> 24)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t  if (offset < 0) throw new RangeError('Index out of range')\n\t}\n\t\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t}\n\t\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n\t  return offset + 8\n\t}\n\t\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t}\n\t\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0\n\t  if (!end && end !== 0) end = this.length\n\t  if (targetStart >= target.length) targetStart = target.length\n\t  if (!targetStart) targetStart = 0\n\t  if (end > 0 && end < start) end = start\n\t\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\t\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\t\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start\n\t  }\n\t\n\t  var len = end - start\n\t  var i\n\t\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; --i) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; ++i) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else {\n\t    Uint8Array.prototype.set.call(\n\t      target,\n\t      this.subarray(start, start + len),\n\t      targetStart\n\t    )\n\t  }\n\t\n\t  return len\n\t}\n\t\n\t// Usage:\n\t//    buffer.fill(number[, offset[, end]])\n\t//    buffer.fill(buffer[, offset[, end]])\n\t//    buffer.fill(string[, offset[, end]][, encoding])\n\tBuffer.prototype.fill = function fill (val, start, end, encoding) {\n\t  // Handle string cases:\n\t  if (typeof val === 'string') {\n\t    if (typeof start === 'string') {\n\t      encoding = start\n\t      start = 0\n\t      end = this.length\n\t    } else if (typeof end === 'string') {\n\t      encoding = end\n\t      end = this.length\n\t    }\n\t    if (val.length === 1) {\n\t      var code = val.charCodeAt(0)\n\t      if (code < 256) {\n\t        val = code\n\t      }\n\t    }\n\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t      throw new TypeError('encoding must be a string')\n\t    }\n\t    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    val = val & 255\n\t  }\n\t\n\t  // Invalid ranges are not set to a default, so can range check early.\n\t  if (start < 0 || this.length < start || this.length < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\t\n\t  if (end <= start) {\n\t    return this\n\t  }\n\t\n\t  start = start >>> 0\n\t  end = end === undefined ? this.length : end >>> 0\n\t\n\t  if (!val) val = 0\n\t\n\t  var i\n\t  if (typeof val === 'number') {\n\t    for (i = start; i < end; ++i) {\n\t      this[i] = val\n\t    }\n\t  } else {\n\t    var bytes = Buffer.isBuffer(val)\n\t      ? val\n\t      : utf8ToBytes(new Buffer(val, encoding).toString())\n\t    var len = bytes.length\n\t    for (i = 0; i < end - start; ++i) {\n\t      this[i + start] = bytes[i % len]\n\t    }\n\t  }\n\t\n\t  return this\n\t}\n\t\n\t// HELPER FUNCTIONS\n\t// ================\n\t\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\t\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '='\n\t  }\n\t  return str\n\t}\n\t\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\t\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\t\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity\n\t  var codePoint\n\t  var length = string.length\n\t  var leadSurrogate = null\n\t  var bytes = []\n\t\n\t  for (var i = 0; i < length; ++i) {\n\t    codePoint = string.charCodeAt(i)\n\t\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        }\n\t\n\t        // valid lead\n\t        leadSurrogate = codePoint\n\t\n\t        continue\n\t      }\n\t\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t        leadSurrogate = codePoint\n\t        continue\n\t      }\n\t\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t    }\n\t\n\t    leadSurrogate = null\n\t\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint)\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\t\n\t  return bytes\n\t}\n\t\n\tfunction asciiToBytes (str) {\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; ++i) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF)\n\t  }\n\t  return byteArray\n\t}\n\t\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; ++i) {\n\t    if ((units -= 2) < 0) break\n\t\n\t    c = str.charCodeAt(i)\n\t    hi = c >> 8\n\t    lo = c % 256\n\t    byteArray.push(lo)\n\t    byteArray.push(hi)\n\t  }\n\t\n\t  return byteArray\n\t}\n\t\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\t\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; ++i) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i]\n\t  }\n\t  return i\n\t}\n\t\n\tfunction isnan (val) {\n\t  return val !== val // eslint-disable-line no-self-compare\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict'\n\t\n\texports.byteLength = byteLength\n\texports.toByteArray = toByteArray\n\texports.fromByteArray = fromByteArray\n\t\n\tvar lookup = []\n\tvar revLookup = []\n\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\t\n\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\tfor (var i = 0, len = code.length; i < len; ++i) {\n\t  lookup[i] = code[i]\n\t  revLookup[code.charCodeAt(i)] = i\n\t}\n\t\n\trevLookup['-'.charCodeAt(0)] = 62\n\trevLookup['_'.charCodeAt(0)] = 63\n\t\n\tfunction placeHoldersCount (b64) {\n\t  var len = b64.length\n\t  if (len % 4 > 0) {\n\t    throw new Error('Invalid string. Length must be a multiple of 4')\n\t  }\n\t\n\t  // the number of equal signs (place holders)\n\t  // if there are two placeholders, than the two characters before it\n\t  // represent one byte\n\t  // if there is only one, then the three characters before it represent 2 bytes\n\t  // this is just a cheap hack to not do indexOf twice\n\t  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\t}\n\t\n\tfunction byteLength (b64) {\n\t  // base64 is 4/3 + up to two characters of the original data\n\t  return b64.length * 3 / 4 - placeHoldersCount(b64)\n\t}\n\t\n\tfunction toByteArray (b64) {\n\t  var i, j, l, tmp, placeHolders, arr\n\t  var len = b64.length\n\t  placeHolders = placeHoldersCount(b64)\n\t\n\t  arr = new Arr(len * 3 / 4 - placeHolders)\n\t\n\t  // if there are placeholders, only get up to the last complete 4 chars\n\t  l = placeHolders > 0 ? len - 4 : len\n\t\n\t  var L = 0\n\t\n\t  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n\t    arr[L++] = (tmp >> 16) & 0xFF\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  if (placeHolders === 2) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n\t    arr[L++] = tmp & 0xFF\n\t  } else if (placeHolders === 1) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  return arr\n\t}\n\t\n\tfunction tripletToBase64 (num) {\n\t  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n\t}\n\t\n\tfunction encodeChunk (uint8, start, end) {\n\t  var tmp\n\t  var output = []\n\t  for (var i = start; i < end; i += 3) {\n\t    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t    output.push(tripletToBase64(tmp))\n\t  }\n\t  return output.join('')\n\t}\n\t\n\tfunction fromByteArray (uint8) {\n\t  var tmp\n\t  var len = uint8.length\n\t  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n\t  var output = ''\n\t  var parts = []\n\t  var maxChunkLength = 16383 // must be multiple of 3\n\t\n\t  // go through the array every three bytes, we'll deal with trailing stuff later\n\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n\t    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n\t  }\n\t\n\t  // pad the end with zeros, but make sure to not forget the extra bytes\n\t  if (extraBytes === 1) {\n\t    tmp = uint8[len - 1]\n\t    output += lookup[tmp >> 2]\n\t    output += lookup[(tmp << 4) & 0x3F]\n\t    output += '=='\n\t  } else if (extraBytes === 2) {\n\t    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n\t    output += lookup[tmp >> 10]\n\t    output += lookup[(tmp >> 4) & 0x3F]\n\t    output += lookup[(tmp << 2) & 0x3F]\n\t    output += '='\n\t  }\n\t\n\t  parts.push(output)\n\t\n\t  return parts.join('')\n\t}\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\texports.read = function (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var nBits = -7\n\t  var i = isLE ? (nBytes - 1) : 0\n\t  var d = isLE ? -1 : 1\n\t  var s = buffer[offset + i]\n\t\n\t  i += d\n\t\n\t  e = s & ((1 << (-nBits)) - 1)\n\t  s >>= (-nBits)\n\t  nBits += eLen\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  m = e & ((1 << (-nBits)) - 1)\n\t  e >>= (-nBits)\n\t  nBits += mLen\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  if (e === 0) {\n\t    e = 1 - eBias\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen)\n\t    e = e - eBias\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\t\n\texports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n\t  var i = isLE ? 0 : (nBytes - 1)\n\t  var d = isLE ? 1 : -1\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\t\n\t  value = Math.abs(value)\n\t\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0\n\t    e = eMax\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2)\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--\n\t      c *= 2\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias)\n\t    }\n\t    if (value * c >= 2) {\n\t      e++\n\t      c /= 2\n\t    }\n\t\n\t    if (e + eBias >= eMax) {\n\t      m = 0\n\t      e = eMax\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen)\n\t      e = e + eBias\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n\t      e = 0\n\t    }\n\t  }\n\t\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\t\n\t  e = (e << mLen) | m\n\t  eLen += mLen\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\t\n\t  buffer[offset + i - d] |= s * 128\n\t}\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// the whatwg-fetch polyfill installs the fetch() function\n\t// on the global object (window or self)\n\t//\n\t// Return that as the export for use in Webpack, Browserify etc.\n\t__webpack_require__(9);\n\tmodule.exports = self.fetch.bind(self);\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t(function(self) {\n\t  'use strict';\n\t\n\t  if (self.fetch) {\n\t    return\n\t  }\n\t\n\t  var support = {\n\t    searchParams: 'URLSearchParams' in self,\n\t    iterable: 'Symbol' in self && 'iterator' in Symbol,\n\t    blob: 'FileReader' in self && 'Blob' in self && (function() {\n\t      try {\n\t        new Blob()\n\t        return true\n\t      } catch(e) {\n\t        return false\n\t      }\n\t    })(),\n\t    formData: 'FormData' in self,\n\t    arrayBuffer: 'ArrayBuffer' in self\n\t  }\n\t\n\t  if (support.arrayBuffer) {\n\t    var viewClasses = [\n\t      '[object Int8Array]',\n\t      '[object Uint8Array]',\n\t      '[object Uint8ClampedArray]',\n\t      '[object Int16Array]',\n\t      '[object Uint16Array]',\n\t      '[object Int32Array]',\n\t      '[object Uint32Array]',\n\t      '[object Float32Array]',\n\t      '[object Float64Array]'\n\t    ]\n\t\n\t    var isDataView = function(obj) {\n\t      return obj && DataView.prototype.isPrototypeOf(obj)\n\t    }\n\t\n\t    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n\t      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n\t    }\n\t  }\n\t\n\t  function normalizeName(name) {\n\t    if (typeof name !== 'string') {\n\t      name = String(name)\n\t    }\n\t    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n\t      throw new TypeError('Invalid character in header field name')\n\t    }\n\t    return name.toLowerCase()\n\t  }\n\t\n\t  function normalizeValue(value) {\n\t    if (typeof value !== 'string') {\n\t      value = String(value)\n\t    }\n\t    return value\n\t  }\n\t\n\t  // Build a destructive iterator for the value list\n\t  function iteratorFor(items) {\n\t    var iterator = {\n\t      next: function() {\n\t        var value = items.shift()\n\t        return {done: value === undefined, value: value}\n\t      }\n\t    }\n\t\n\t    if (support.iterable) {\n\t      iterator[Symbol.iterator] = function() {\n\t        return iterator\n\t      }\n\t    }\n\t\n\t    return iterator\n\t  }\n\t\n\t  function Headers(headers) {\n\t    this.map = {}\n\t\n\t    if (headers instanceof Headers) {\n\t      headers.forEach(function(value, name) {\n\t        this.append(name, value)\n\t      }, this)\n\t\n\t    } else if (headers) {\n\t      Object.getOwnPropertyNames(headers).forEach(function(name) {\n\t        this.append(name, headers[name])\n\t      }, this)\n\t    }\n\t  }\n\t\n\t  Headers.prototype.append = function(name, value) {\n\t    name = normalizeName(name)\n\t    value = normalizeValue(value)\n\t    var oldValue = this.map[name]\n\t    this.map[name] = oldValue ? oldValue+','+value : value\n\t  }\n\t\n\t  Headers.prototype['delete'] = function(name) {\n\t    delete this.map[normalizeName(name)]\n\t  }\n\t\n\t  Headers.prototype.get = function(name) {\n\t    name = normalizeName(name)\n\t    return this.has(name) ? this.map[name] : null\n\t  }\n\t\n\t  Headers.prototype.has = function(name) {\n\t    return this.map.hasOwnProperty(normalizeName(name))\n\t  }\n\t\n\t  Headers.prototype.set = function(name, value) {\n\t    this.map[normalizeName(name)] = normalizeValue(value)\n\t  }\n\t\n\t  Headers.prototype.forEach = function(callback, thisArg) {\n\t    for (var name in this.map) {\n\t      if (this.map.hasOwnProperty(name)) {\n\t        callback.call(thisArg, this.map[name], name, this)\n\t      }\n\t    }\n\t  }\n\t\n\t  Headers.prototype.keys = function() {\n\t    var items = []\n\t    this.forEach(function(value, name) { items.push(name) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  Headers.prototype.values = function() {\n\t    var items = []\n\t    this.forEach(function(value) { items.push(value) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  Headers.prototype.entries = function() {\n\t    var items = []\n\t    this.forEach(function(value, name) { items.push([name, value]) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  if (support.iterable) {\n\t    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n\t  }\n\t\n\t  function consumed(body) {\n\t    if (body.bodyUsed) {\n\t      return Promise.reject(new TypeError('Already read'))\n\t    }\n\t    body.bodyUsed = true\n\t  }\n\t\n\t  function fileReaderReady(reader) {\n\t    return new Promise(function(resolve, reject) {\n\t      reader.onload = function() {\n\t        resolve(reader.result)\n\t      }\n\t      reader.onerror = function() {\n\t        reject(reader.error)\n\t      }\n\t    })\n\t  }\n\t\n\t  function readBlobAsArrayBuffer(blob) {\n\t    var reader = new FileReader()\n\t    var promise = fileReaderReady(reader)\n\t    reader.readAsArrayBuffer(blob)\n\t    return promise\n\t  }\n\t\n\t  function readBlobAsText(blob) {\n\t    var reader = new FileReader()\n\t    var promise = fileReaderReady(reader)\n\t    reader.readAsText(blob)\n\t    return promise\n\t  }\n\t\n\t  function readArrayBufferAsText(buf) {\n\t    var view = new Uint8Array(buf)\n\t    var chars = new Array(view.length)\n\t\n\t    for (var i = 0; i < view.length; i++) {\n\t      chars[i] = String.fromCharCode(view[i])\n\t    }\n\t    return chars.join('')\n\t  }\n\t\n\t  function bufferClone(buf) {\n\t    if (buf.slice) {\n\t      return buf.slice(0)\n\t    } else {\n\t      var view = new Uint8Array(buf.byteLength)\n\t      view.set(new Uint8Array(buf))\n\t      return view.buffer\n\t    }\n\t  }\n\t\n\t  function Body() {\n\t    this.bodyUsed = false\n\t\n\t    this._initBody = function(body) {\n\t      this._bodyInit = body\n\t      if (!body) {\n\t        this._bodyText = ''\n\t      } else if (typeof body === 'string') {\n\t        this._bodyText = body\n\t      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n\t        this._bodyBlob = body\n\t      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n\t        this._bodyFormData = body\n\t      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n\t        this._bodyText = body.toString()\n\t      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n\t        this._bodyArrayBuffer = bufferClone(body.buffer)\n\t        // IE 10-11 can't handle a DataView body.\n\t        this._bodyInit = new Blob([this._bodyArrayBuffer])\n\t      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n\t        this._bodyArrayBuffer = bufferClone(body)\n\t      } else {\n\t        throw new Error('unsupported BodyInit type')\n\t      }\n\t\n\t      if (!this.headers.get('content-type')) {\n\t        if (typeof body === 'string') {\n\t          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n\t        } else if (this._bodyBlob && this._bodyBlob.type) {\n\t          this.headers.set('content-type', this._bodyBlob.type)\n\t        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n\t          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n\t        }\n\t      }\n\t    }\n\t\n\t    if (support.blob) {\n\t      this.blob = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return Promise.resolve(this._bodyBlob)\n\t        } else if (this._bodyArrayBuffer) {\n\t          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as blob')\n\t        } else {\n\t          return Promise.resolve(new Blob([this._bodyText]))\n\t        }\n\t      }\n\t\n\t      this.arrayBuffer = function() {\n\t        if (this._bodyArrayBuffer) {\n\t          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n\t        } else {\n\t          return this.blob().then(readBlobAsArrayBuffer)\n\t        }\n\t      }\n\t    }\n\t\n\t    this.text = function() {\n\t      var rejected = consumed(this)\n\t      if (rejected) {\n\t        return rejected\n\t      }\n\t\n\t      if (this._bodyBlob) {\n\t        return readBlobAsText(this._bodyBlob)\n\t      } else if (this._bodyArrayBuffer) {\n\t        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n\t      } else if (this._bodyFormData) {\n\t        throw new Error('could not read FormData body as text')\n\t      } else {\n\t        return Promise.resolve(this._bodyText)\n\t      }\n\t    }\n\t\n\t    if (support.formData) {\n\t      this.formData = function() {\n\t        return this.text().then(decode)\n\t      }\n\t    }\n\t\n\t    this.json = function() {\n\t      return this.text().then(JSON.parse)\n\t    }\n\t\n\t    return this\n\t  }\n\t\n\t  // HTTP methods whose capitalization should be normalized\n\t  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\t\n\t  function normalizeMethod(method) {\n\t    var upcased = method.toUpperCase()\n\t    return (methods.indexOf(upcased) > -1) ? upcased : method\n\t  }\n\t\n\t  function Request(input, options) {\n\t    options = options || {}\n\t    var body = options.body\n\t\n\t    if (input instanceof Request) {\n\t      if (input.bodyUsed) {\n\t        throw new TypeError('Already read')\n\t      }\n\t      this.url = input.url\n\t      this.credentials = input.credentials\n\t      if (!options.headers) {\n\t        this.headers = new Headers(input.headers)\n\t      }\n\t      this.method = input.method\n\t      this.mode = input.mode\n\t      if (!body && input._bodyInit != null) {\n\t        body = input._bodyInit\n\t        input.bodyUsed = true\n\t      }\n\t    } else {\n\t      this.url = String(input)\n\t    }\n\t\n\t    this.credentials = options.credentials || this.credentials || 'omit'\n\t    if (options.headers || !this.headers) {\n\t      this.headers = new Headers(options.headers)\n\t    }\n\t    this.method = normalizeMethod(options.method || this.method || 'GET')\n\t    this.mode = options.mode || this.mode || null\n\t    this.referrer = null\n\t\n\t    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n\t      throw new TypeError('Body not allowed for GET or HEAD requests')\n\t    }\n\t    this._initBody(body)\n\t  }\n\t\n\t  Request.prototype.clone = function() {\n\t    return new Request(this, { body: this._bodyInit })\n\t  }\n\t\n\t  function decode(body) {\n\t    var form = new FormData()\n\t    body.trim().split('&').forEach(function(bytes) {\n\t      if (bytes) {\n\t        var split = bytes.split('=')\n\t        var name = split.shift().replace(/\\+/g, ' ')\n\t        var value = split.join('=').replace(/\\+/g, ' ')\n\t        form.append(decodeURIComponent(name), decodeURIComponent(value))\n\t      }\n\t    })\n\t    return form\n\t  }\n\t\n\t  function parseHeaders(rawHeaders) {\n\t    var headers = new Headers()\n\t    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n\t      var parts = line.split(':')\n\t      var key = parts.shift().trim()\n\t      if (key) {\n\t        var value = parts.join(':').trim()\n\t        headers.append(key, value)\n\t      }\n\t    })\n\t    return headers\n\t  }\n\t\n\t  Body.call(Request.prototype)\n\t\n\t  function Response(bodyInit, options) {\n\t    if (!options) {\n\t      options = {}\n\t    }\n\t\n\t    this.type = 'default'\n\t    this.status = 'status' in options ? options.status : 200\n\t    this.ok = this.status >= 200 && this.status < 300\n\t    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n\t    this.headers = new Headers(options.headers)\n\t    this.url = options.url || ''\n\t    this._initBody(bodyInit)\n\t  }\n\t\n\t  Body.call(Response.prototype)\n\t\n\t  Response.prototype.clone = function() {\n\t    return new Response(this._bodyInit, {\n\t      status: this.status,\n\t      statusText: this.statusText,\n\t      headers: new Headers(this.headers),\n\t      url: this.url\n\t    })\n\t  }\n\t\n\t  Response.error = function() {\n\t    var response = new Response(null, {status: 0, statusText: ''})\n\t    response.type = 'error'\n\t    return response\n\t  }\n\t\n\t  var redirectStatuses = [301, 302, 303, 307, 308]\n\t\n\t  Response.redirect = function(url, status) {\n\t    if (redirectStatuses.indexOf(status) === -1) {\n\t      throw new RangeError('Invalid status code')\n\t    }\n\t\n\t    return new Response(null, {status: status, headers: {location: url}})\n\t  }\n\t\n\t  self.Headers = Headers\n\t  self.Request = Request\n\t  self.Response = Response\n\t\n\t  self.fetch = function(input, init) {\n\t    return new Promise(function(resolve, reject) {\n\t      var request = new Request(input, init)\n\t      var xhr = new XMLHttpRequest()\n\t\n\t      xhr.onload = function() {\n\t        var options = {\n\t          status: xhr.status,\n\t          statusText: xhr.statusText,\n\t          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n\t        }\n\t        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n\t        var body = 'response' in xhr ? xhr.response : xhr.responseText\n\t        resolve(new Response(body, options))\n\t      }\n\t\n\t      xhr.onerror = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.ontimeout = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.open(request.method, request.url, true)\n\t\n\t      if (request.credentials === 'include') {\n\t        xhr.withCredentials = true\n\t      }\n\t\n\t      if ('responseType' in xhr && support.blob) {\n\t        xhr.responseType = 'blob'\n\t      }\n\t\n\t      request.headers.forEach(function(value, name) {\n\t        xhr.setRequestHeader(name, value)\n\t      })\n\t\n\t      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n\t    })\n\t  }\n\t  self.fetch.polyfill = true\n\t})(typeof self !== 'undefined' ? self : this);\n\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// baas.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b892022d7770bbce47d1","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Admin = exports.MongoClient = exports.BaasClient = exports.ErrInvalidSession = exports.ErrAuthProviderNotFound = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _auth = require('./auth');\n\nvar _auth2 = _interopRequireDefault(_auth);\n\nvar _common = require('./common');\n\nvar common = _interopRequireWildcard(_common);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* global window, fetch */\n/* eslint no-labels: ['error', { 'allowLoop': true }] */\nrequire('isomorphic-fetch');\n\nvar ErrAuthProviderNotFound = exports.ErrAuthProviderNotFound = 'AuthProviderNotFound';\nvar ErrInvalidSession = exports.ErrInvalidSession = 'InvalidSession';\n\nvar toQueryString = function toQueryString(obj) {\n  var parts = [];\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      parts.push(encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]));\n    }\n  }\n  return parts.join('&');\n};\n\nvar BaasClient = exports.BaasClient = function () {\n  function BaasClient(clientAppID, options) {\n    _classCallCheck(this, BaasClient);\n\n    var baseUrl = common.DEFAULT_BAAS_SERVER_URL;\n    if (options && options.baseUrl) {\n      baseUrl = options.baseUrl;\n    }\n    this.appUrl = baseUrl + '/admin/v1';\n    this.authUrl = baseUrl + '/admin/v1/auth';\n    if (clientAppID) {\n      this.appUrl = baseUrl + '/v1/app/' + clientAppID;\n      this.authUrl = this.appUrl + '/auth';\n    }\n    this.authManager = new _auth2.default(this.authUrl);\n    this.authManager.handleRedirect();\n  }\n\n  _createClass(BaasClient, [{\n    key: 'authWithOAuth',\n    value: function authWithOAuth(providerName, redirectUrl) {\n      window.location.replace(this.authManager.getOAuthLoginURL(providerName, redirectUrl));\n    }\n  }, {\n    key: 'authedId',\n    value: function authedId() {\n      return this.authManager.authedId();\n    }\n  }, {\n    key: 'auth',\n    value: function auth() {\n      return this.authManager.get();\n    }\n  }, {\n    key: 'authError',\n    value: function authError() {\n      return this.authManager.error();\n    }\n  }, {\n    key: 'logout',\n    value: function logout() {\n      var _this = this;\n\n      return this._doAuthed('/auth', 'DELETE', { refreshOnFailure: false, useRefreshToken: true }).then(function (data) {\n        _this.authManager.clear();\n      });\n    }\n\n    // wrapper around fetch() that matches the signature of doAuthed but does not\n    // actually use any auth. This is necessary for routes that must be\n    // accessible without logging in, like listing available auth providers.\n\n  }, {\n    key: '_do',\n    value: function _do(resource, method, options) {\n      options = options || {};\n      var url = '' + this.appUrl + resource;\n      var init = {\n        method: method,\n        headers: { 'Accept': common.JSONTYPE, 'Content-Type': common.JSONTYPE }\n      };\n      if (options.body) {\n        init['body'] = options.body;\n      }\n      if (options.queryParams) {\n        url = url + '?' + toQueryString(options.queryParams);\n      }\n\n      return fetch(url, init).then(function (response) {\n        // Okay: passthrough\n        if (response.status >= 200 && response.status < 300) {\n          return Promise.resolve(response);\n        } else if (response.headers.get('Content-Type') === common.JSONTYPE) {\n          return response.json().then(function (json) {\n            var error = new common.BaasError(json['error'], json['errorCode']);\n            error.response = response;\n            throw error;\n          });\n        }\n        var error = new Error(response.statusText);\n        error.response = response;\n        throw error;\n      }).then(function (response) {\n        return response.json();\n      });\n    }\n  }, {\n    key: '_doAuthed',\n    value: function _doAuthed(resource, method, options) {\n      var _this2 = this;\n\n      if (options === undefined) {\n        options = { refreshOnFailure: true, useRefreshToken: false };\n      } else {\n        if (options.refreshOnFailure === undefined) {\n          options.refreshOnFailure = true;\n        }\n        if (options.useRefreshToken === undefined) {\n          options.useRefreshToken = false;\n        }\n      }\n\n      if (this.auth() === null) {\n        return Promise.reject(new common.BaasError('Must auth first'));\n      }\n\n      var url = '' + this.appUrl + resource;\n\n      var headers = {\n        'Accept': common.JSONTYPE,\n        'Content-Type': common.JSONTYPE\n      };\n      var token = options.useRefreshToken ? this.authManager.getRefreshToken() : this.auth()['accessToken'];\n      headers['Authorization'] = 'Bearer ' + token;\n\n      var init = {\n        method: method,\n        headers: headers\n      };\n\n      if (options.body) {\n        init['body'] = options.body;\n      }\n\n      if (options.queryParams) {\n        url = url + '?' + toQueryString(options.queryParams);\n      }\n\n      return fetch(url, init).then(function (response) {\n        // Okay: passthrough\n        if (response.status >= 200 && response.status < 300) {\n          return Promise.resolve(response);\n        } else if (response.headers.get('Content-Type') === common.JSONTYPE) {\n          return response.json().then(function (json) {\n            // Only want to try refreshing token when there's an invalid session\n            if ('errorCode' in json && json['errorCode'] === ErrInvalidSession) {\n              if (!options.refreshOnFailure) {\n                _this2.authManager.clear();\n                var _error = new common.BaasError(json['error'], json['errorCode']);\n                _error.response = response;\n                throw _error;\n              }\n\n              return _this2._refreshToken().then(function () {\n                options.refreshOnFailure = false;\n                return _this2._doAuthed(resource, method, options);\n              });\n            }\n\n            var error = new common.BaasError(json['error'], json['errorCode']);\n            error.response = response;\n            throw error;\n          });\n        }\n\n        var error = new Error(response.statusText);\n        error.response = response;\n        throw error;\n      });\n    }\n  }, {\n    key: '_refreshToken',\n    value: function _refreshToken() {\n      var _this3 = this;\n\n      if (this.authManager.isImpersonatingUser()) {\n        return this.authManager.refreshImpersonation(this);\n      }\n      return this._doAuthed('/auth/newAccessToken', 'POST', { refreshOnFailure: false, useRefreshToken: true }).then(function (response) {\n        return response.json().then(function (json) {\n          _this3.authManager.setAccessToken(json['accessToken']);\n          return Promise.resolve();\n        });\n      });\n    }\n  }, {\n    key: 'executePipeline',\n    value: function executePipeline(stages, options) {\n      var responseDecoder = JSON.parse;\n      var responseEncoder = JSON.stringify;\n      if (options) {\n        if (options.decoder) {\n          if (typeof options.decoder !== 'function') {\n            throw new Error('decoder option must be a function, but \"' + _typeof(options.decoder) + '\" was provided');\n          }\n          responseDecoder = options.decoder;\n        }\n        if (options.encoder) {\n          if (typeof options.encoder !== 'function') {\n            throw new Error('encoder option must be a function, but \"' + _typeof(options.encoder) + '\" was provided');\n          }\n          responseEncoder = options.encoder;\n        }\n      }\n      return this._doAuthed('/pipeline', 'POST', { body: responseEncoder(stages) }).then(function (response) {\n        if (response.arrayBuffer) {\n          return response.arrayBuffer();\n        }\n        return response.buffer();\n      }).then(function (buf) {\n        return new common.TextDecoder('utf-8').decode(buf);\n      }).then(function (body) {\n        return responseDecoder(body);\n      });\n    }\n  }]);\n\n  return BaasClient;\n}();\n\nvar DB = function () {\n  function DB(client, service, name) {\n    _classCallCheck(this, DB);\n\n    this.client = client;\n    this.service = service;\n    this.name = name;\n  }\n\n  _createClass(DB, [{\n    key: 'getCollection',\n    value: function getCollection(name) {\n      return new Collection(this, name);\n    }\n  }]);\n\n  return DB;\n}();\n\nvar Collection = function () {\n  function Collection(db, name) {\n    _classCallCheck(this, Collection);\n\n    this.db = db;\n    this.name = name;\n  }\n\n  _createClass(Collection, [{\n    key: 'getBaseArgs',\n    value: function getBaseArgs() {\n      return {\n        'database': this.db.name,\n        'collection': this.name\n      };\n    }\n  }, {\n    key: 'deleteOne',\n    value: function deleteOne(query) {\n      var args = this.getBaseArgs();\n      args.query = query;\n      args.singleDoc = true;\n      return this.db.client.executePipeline([{\n        'service': this.db.service,\n        'action': 'delete',\n        'args': args\n      }]);\n    }\n  }, {\n    key: 'deleteMany',\n    value: function deleteMany(query) {\n      var args = this.getBaseArgs();\n      args.query = query;\n      args.singleDoc = false;\n      return this.db.client.executePipeline([{\n        'service': this.db.service,\n        'action': 'delete',\n        'args': args\n      }]);\n    }\n  }, {\n    key: 'find',\n    value: function find(query, project) {\n      var args = this.getBaseArgs();\n      args.query = query;\n      args.project = project;\n      return this.db.client.executePipeline([{\n        'service': this.db.service,\n        'action': 'find',\n        'args': args\n      }]);\n    }\n  }, {\n    key: 'insert',\n    value: function insert(docs) {\n      var toInsert = void 0;\n      if (docs instanceof Array) {\n        toInsert = docs;\n      } else {\n        toInsert = Array.from(arguments);\n      }\n\n      return this.db.client.executePipeline([{ 'action': 'literal',\n        'args': {\n          'items': toInsert\n        }\n      }, {\n        'service': this.db.service,\n        'action': 'insert',\n        'args': this.getBaseArgs()\n      }]);\n    }\n  }, {\n    key: 'makeUpdateStage',\n    value: function makeUpdateStage(query, update, upsert, multi) {\n      var args = this.getBaseArgs();\n      args.query = query;\n      args.update = update;\n      if (upsert) {\n        args.upsert = true;\n      }\n      if (multi) {\n        args.multi = true;\n      }\n\n      return {\n        'service': this.db.service,\n        'action': 'update',\n        'args': args\n      };\n    }\n  }, {\n    key: 'updateOne',\n    value: function updateOne(query, update) {\n      return this.db.client.executePipeline([this.makeUpdateStage(query, update, false, false)]);\n    }\n  }, {\n    key: 'updateMany',\n    value: function updateMany(query, update, upsert, multi) {\n      return this.db.client.executePipeline([this.makeUpdateStage(query, update, false, true)]);\n    }\n  }, {\n    key: 'upsert',\n    value: function upsert(query, update) {\n      return this.db.client.executePipeline([this.makeUpdateStage(query, update, true, false)]);\n    }\n  }]);\n\n  return Collection;\n}();\n\nvar MongoClient = exports.MongoClient = function () {\n  function MongoClient(baasClient, serviceName) {\n    _classCallCheck(this, MongoClient);\n\n    this.baasClient = baasClient;\n    this.service = serviceName;\n  }\n\n  _createClass(MongoClient, [{\n    key: 'getDb',\n    value: function getDb(name) {\n      return new DB(this.baasClient, this.service, name);\n    }\n  }]);\n\n  return MongoClient;\n}();\n\nvar Admin = exports.Admin = function () {\n  function Admin(baseUrl) {\n    _classCallCheck(this, Admin);\n\n    this.client = new BaasClient('', { baseUrl: baseUrl });\n  }\n\n  _createClass(Admin, [{\n    key: '_doAuthed',\n    value: function _doAuthed(url, method, options) {\n      return this.client._doAuthed(url, method, options).then(function (response) {\n        return response.json();\n      });\n    }\n  }, {\n    key: '_get',\n    value: function _get(url, queryParams) {\n      return this._doAuthed(url, 'GET', { queryParams: queryParams });\n    }\n  }, {\n    key: '_put',\n    value: function _put(url, queryParams) {\n      return this._doAuthed(url, 'PUT', { queryParams: queryParams });\n    }\n  }, {\n    key: '_delete',\n    value: function _delete(url) {\n      return this._doAuthed(url, 'DELETE');\n    }\n  }, {\n    key: '_post',\n    value: function _post(url, body) {\n      return this._doAuthed(url, 'POST', { body: JSON.stringify(body) });\n    }\n  }, {\n    key: 'profile',\n    value: function profile() {\n      var _this4 = this;\n\n      var root = this;\n      return {\n        keys: function keys() {\n          return {\n            list: function list() {\n              return root._get('/profile/keys');\n            },\n            create: function create(key) {\n              return root._post('/profile/keys');\n            },\n            apiKey: function apiKey(keyId) {\n              return {\n                get: function get() {\n                  return root._get('/profile/keys/' + keyId);\n                },\n                remove: function remove() {\n                  return _this4._delete('/profile/keys/' + keyId);\n                },\n                enable: function enable() {\n                  return root._put('/profile/keys/' + keyId + '/enable');\n                },\n                disable: function disable() {\n                  return root._put('/profile/keys/' + keyId + '/disable');\n                }\n              };\n            }\n          };\n        }\n      };\n    }\n\n    /* Examples of how to access admin API with this client:\n     *\n     * List all apps\n     *    a.apps().list()\n     *\n     * Fetch app under name 'planner'\n     *    a.apps().app('planner').get()\n     *\n     * List services under the app 'planner'\n     *    a.apps().app('planner').services().list()\n     *\n     * Delete a rule by ID\n     *    a.apps().app('planner').services().service('mdb1').rules().rule('580e6d055b199c221fcb821d').remove()\n     *\n     */\n\n  }, {\n    key: 'apps',\n    value: function apps() {\n      var _this5 = this;\n\n      var root = this;\n      return {\n        list: function list() {\n          return root._get('/apps');\n        },\n        create: function create(data) {\n          return root._post('/apps', data);\n        },\n        app: function app(appID) {\n          return {\n            get: function get() {\n              return root._get('/apps/' + appID);\n            },\n            remove: function remove() {\n              return root._delete('/apps/' + appID);\n            },\n\n            users: function users() {\n              return {\n                list: function list(filter) {\n                  return _this5._get('/apps/' + appID + '/users', filter);\n                },\n                user: function user(uid) {\n                  return {\n                    get: function get() {\n                      return _this5._get('/apps/' + appID + '/users/' + uid);\n                    },\n                    logout: function logout() {\n                      return _this5._put('/apps/' + appID + '/users/' + uid + '/logout');\n                    }\n                  };\n                }\n              };\n            },\n\n            sandbox: function sandbox() {\n              return {\n                executePipeline: function executePipeline(data, userId) {\n                  return _this5._doAuthed('/apps/' + appID + '/sandbox/pipeline', 'POST', { body: JSON.stringify(data), queryParams: { user_id: userId } });\n                }\n              };\n            },\n\n            authProviders: function authProviders() {\n              return {\n                create: function create(data) {\n                  return _this5._post('/apps/' + appID + '/authProviders', data);\n                },\n                list: function list() {\n                  return _this5._get('/apps/' + appID + '/authProviders');\n                },\n                provider: function provider(authType, authName) {\n                  return {\n                    get: function get() {\n                      return _this5._get('/apps/' + appID + '/authProviders/' + authType + '/' + authName);\n                    },\n                    remove: function remove() {\n                      return _this5._delete('/apps/' + appID + '/authProviders/' + authType + '/' + authName);\n                    },\n                    update: function update(data) {\n                      return _this5._post('/apps/' + appID + '/authProviders/' + authType + '/' + authName, data);\n                    }\n                  };\n                }\n              };\n            },\n            variables: function variables() {\n              return {\n                list: function list() {\n                  return _this5._get('/apps/' + appID + '/vars');\n                },\n                variable: function variable(varName) {\n                  return {\n                    get: function get() {\n                      return _this5._get('/apps/' + appID + '/vars/' + varName);\n                    },\n                    remove: function remove() {\n                      return _this5._delete('/apps/' + appID + '/vars/' + varName);\n                    },\n                    create: function create(data) {\n                      return _this5._post('/apps/' + appID + '/vars/' + varName, data);\n                    },\n                    update: function update(data) {\n                      return _this5._post('/apps/' + appID + '/vars/' + varName, data);\n                    }\n                  };\n                }\n              };\n            },\n            logs: function logs() {\n              return {\n                get: function get(filter) {\n                  return _this5._get('/apps/' + appID + '/logs', filter);\n                }\n              };\n            },\n            apiKeys: function apiKeys() {\n              return {\n                list: function list() {\n                  return _this5._get('/apps/' + appID + '/keys');\n                },\n                create: function create(data) {\n                  return _this5._post('/apps/' + appID + '/keys', data);\n                },\n                apiKey: function apiKey(key) {\n                  return {\n                    get: function get() {\n                      return _this5._get('/apps/' + appID + '/keys/' + key);\n                    },\n                    remove: function remove() {\n                      return _this5._delete('/apps/' + appID + '/keys/' + key);\n                    },\n                    enable: function enable() {\n                      return _this5._put('/apps/' + appID + '/keys/' + key + '/enable');\n                    },\n                    disable: function disable() {\n                      return _this5._put('/apps/' + appID + '/keys/' + key + '/disable');\n                    }\n                  };\n                }\n              };\n            },\n            services: function services() {\n              return {\n                list: function list() {\n                  return _this5._get('/apps/' + appID + '/services');\n                },\n                create: function create(data) {\n                  return _this5._post('/apps/' + appID + '/services', data);\n                },\n                service: function service(svc) {\n                  return {\n                    get: function get() {\n                      return _this5._get('/apps/' + appID + '/services/' + svc);\n                    },\n                    update: function update(data) {\n                      return _this5._post('/apps/' + appID + '/services/' + svc, data);\n                    },\n                    remove: function remove() {\n                      return _this5._delete('/apps/' + appID + '/services/' + svc);\n                    },\n                    setConfig: function setConfig(data) {\n                      return _this5._post('/apps/' + appID + '/services/' + svc + '/config', data);\n                    },\n\n                    rules: function rules() {\n                      return {\n                        list: function list() {\n                          return _this5._get('/apps/' + appID + '/services/' + svc + '/rules');\n                        },\n                        create: function create(data) {\n                          return _this5._post('/apps/' + appID + '/services/' + svc + '/rules');\n                        },\n                        rule: function rule(ruleId) {\n                          return {\n                            get: function get() {\n                              return _this5._get('/apps/' + appID + '/services/' + svc + '/rules/' + ruleId);\n                            },\n                            update: function update(data) {\n                              return _this5._post('/apps/' + appID + '/services/' + svc + '/rules/' + ruleId, data);\n                            },\n                            remove: function remove() {\n                              return _this5._delete('/apps/' + appID + '/services/' + svc + '/rules/' + ruleId);\n                            }\n                          };\n                        }\n                      };\n                    },\n\n                    triggers: function triggers() {\n                      return {\n                        list: function list() {\n                          return _this5._get('/apps/' + appID + '/services/' + svc + '/triggers');\n                        },\n                        create: function create(data) {\n                          return _this5._post('/apps/' + appID + '/services/' + svc + '/triggers');\n                        },\n                        trigger: function trigger(triggerId) {\n                          return {\n                            get: function get() {\n                              return _this5._get('/apps/' + appID + '/services/' + svc + '/triggers/' + triggerId);\n                            },\n                            update: function update(data) {\n                              return _this5._post('/apps/' + appID + '/services/' + svc + '/triggers/' + triggerId, data);\n                            },\n                            remove: function remove() {\n                              return _this5._delete('/apps/' + appID + '/services/' + svc + '/triggers/' + triggerId);\n                            }\n                          };\n                        }\n                      };\n                    }\n                  };\n                }\n              };\n            }\n          };\n        }\n      };\n    }\n  }, {\n    key: '_admin',\n    value: function _admin() {\n      var _this6 = this;\n\n      return {\n        logs: function logs() {\n          return {\n            get: function get(filter) {\n              return _this6._doAuthed('/admin/logs', 'GET', { useRefreshToken: true, queryParams: filter });\n            }\n          };\n        },\n        users: function users() {\n          return {\n            list: function list(filter) {\n              return _this6._doAuthed('/admin/users', 'GET', { useRefreshToken: true, queryParams: filter });\n            },\n            user: function user(uid) {\n              return {\n                logout: function logout() {\n                  return _this6._doAuthed('/admin/users/' + uid + '/logout', 'PUT', { useRefreshToken: true });\n                }\n              };\n            }\n          };\n        }\n      };\n    }\n  }, {\n    key: '_isImpersonatingUser',\n    value: function _isImpersonatingUser() {\n      return this.client.authManager.isImpersonatingUser();\n    }\n  }, {\n    key: '_startImpersonation',\n    value: function _startImpersonation(userId) {\n      return this.client.authManager.startImpersonation(this.client, userId);\n    }\n  }, {\n    key: '_stopImpersonation',\n    value: function _stopImpersonation(userId) {\n      return this.client.authManager.stopImpersonation();\n    }\n  }]);\n\n  return Admin;\n}();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./distribution/client.js\n// module id = 0\n// module chunks = 0 1","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global window, fetch */\n\n/* let authDataStorage;\nif(window !== undefined && window.localStorage !== undefined){\n  authDataStorage = window.localStorage\n}\n\n*/\n\nvar _common = require('./common');\n\nvar common = _interopRequireWildcard(_common);\n\nvar _jsBase = require('js-base64');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar AuthDataStorage = function () {\n  function AuthDataStorage() {\n    _classCallCheck(this, AuthDataStorage);\n\n    this._data = {};\n  }\n\n  _createClass(AuthDataStorage, [{\n    key: 'setItem',\n    value: function setItem(id, val) {\n      this._data[id] = String(val);\n    }\n  }, {\n    key: 'getItem',\n    value: function getItem(id) {\n      return this._data.hasOwnProperty(id) ? this._data[id] : undefined;\n    }\n  }, {\n    key: 'removeItem',\n    value: function removeItem(id) {\n      return delete this._data[id];\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this._data = {};\n    }\n  }]);\n\n  return AuthDataStorage;\n}();\n\nvar Auth = function () {\n  function Auth(rootUrl) {\n    _classCallCheck(this, Auth);\n\n    this.rootUrl = rootUrl;\n    if (typeof window !== 'undefined' && window.localStorage !== undefined) {\n      this.authDataStorage = window.localStorage;\n    } else {\n      this.authDataStorage = new AuthDataStorage();\n    }\n  }\n\n  _createClass(Auth, [{\n    key: 'pageRootUrl',\n    value: function pageRootUrl() {\n      return [window.location.protocol, '//', window.location.host, window.location.pathname].join('');\n    }\n\n    // The state we generate is to be used for any kind of request where we will\n    // complete an authentication flow via a redirect. We store the generate in\n    // a local storage bound to the app's origin. This ensures that any time we\n    // receive a redirect, there must be a state parameter and it must match\n    // what we ourselves have generated. This state MUST only be sent to\n    // a trusted BaaS endpoint in order to preserve its integrity. BaaS will\n    // store it in some way on its origin (currently a cookie stored on this client)\n    // and use that state at the end of an auth flow as a parameter in the redirect URI.\n\n  }, {\n    key: 'setAccessToken',\n    value: function setAccessToken(token) {\n      var currAuth = this.get();\n      currAuth['accessToken'] = token;\n      currAuth['refreshToken'] = this.authDataStorage.getItem(common.REFRESH_TOKEN_KEY);\n      this.set(currAuth);\n    }\n  }, {\n    key: 'error',\n    value: function error() {\n      return this._error;\n    }\n  }, {\n    key: 'handleRedirect',\n    value: function handleRedirect() {\n      var ourState = this.authDataStorage.getItem(common.STATE_KEY);\n      if (typeof window === 'undefined') {\n        // This means we're running in some environment other\n        // than a browser - so handling a redirect makes no sense here.\n        return;\n      }\n      var redirectFragment = window.location.hash.substring(1);\n      var redirectState = common.parseRedirectFragment(redirectFragment, ourState);\n      if (redirectState.lastError) {\n        console.error('BaasClient: error from redirect: ' + redirectState.lastError);\n        this._error = redirectState.lastError;\n        window.history.replaceState(null, '', this.pageRootUrl());\n        return;\n      }\n      if (!redirectState.found) {\n        return;\n      }\n      this.authDataStorage.removeItem(common.STATE_KEY);\n      if (!redirectState.stateValid) {\n        console.error('BaasClient: state values did not match!');\n        window.history.replaceState(null, '', this.pageRootUrl());\n        return;\n      }\n      if (!redirectState.ua) {\n        console.error('BaasClient: no UA value was returned from redirect!');\n        return;\n      }\n      // If we get here, the state is valid - set auth appropriately.\n      this.set(redirectState.ua);\n      window.history.replaceState(null, '', this.pageRootUrl());\n    }\n  }, {\n    key: 'getOAuthLoginURL',\n    value: function getOAuthLoginURL(providerName, redirectUrl) {\n      if (redirectUrl === undefined) {\n        redirectUrl = this.pageRootUrl();\n      }\n      var state = Auth.generateState();\n      this.authDataStorage.setItem(common.STATE_KEY, state);\n      var result = this.rootUrl + '/oauth2/' + providerName + '?redirect=' + encodeURI(redirectUrl) + '&state=' + state;\n      return result;\n    }\n  }, {\n    key: 'anonymousAuth',\n    value: function anonymousAuth(cors) {\n      var _this = this;\n\n      var init = {\n        method: 'GET',\n        headers: {\n          'Accept': common.JSONTYPE,\n          'Content-Type': common.JSONTYPE\n        }\n      };\n\n      // TODO get rid of the cors flag. it should just be on all the time.\n      if (cors) {\n        init['cors'] = cors;\n      }\n\n      return fetch(this.rootUrl + '/anon/user', init).then(common.checkStatus).then(function (response) {\n        return response.json().then(function (json) {\n          _this.set(json);\n          Promise.resolve();\n        });\n      });\n    }\n  }, {\n    key: 'apiKeyAuth',\n    value: function apiKeyAuth(key) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { cors: true };\n\n      var init = {\n        method: 'POST',\n        headers: {\n          'Accept': common.JSONTYPE,\n          'Content-Type': common.JSONTYPE\n        },\n        body: JSON.stringify({ 'key': key })\n      };\n\n      if (options && options.cors === false) {\n        init['cors'] = false;\n      } else {\n        init['cors'] = true;\n      }\n\n      return fetch(this.rootUrl + '/api/key', init).then(common.checkStatus).then(function (response) {\n        return response.json().then(function (json) {\n          _this2.set(json);\n          return Promise.resolve();\n        });\n      });\n    }\n  }, {\n    key: 'localAuth',\n    value: function localAuth(username, password) {\n      var _this3 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { cors: true };\n\n      var init = {\n        method: 'POST',\n        headers: {\n          'Accept': common.JSONTYPE,\n          'Content-Type': common.JSONTYPE\n        },\n        body: JSON.stringify({ 'username': username, 'password': password })\n      };\n\n      if (options && options.cors === false) {\n        init['cors'] = false;\n      } else {\n        init['cors'] = true;\n      }\n\n      return fetch(this.rootUrl + '/local/userpass', init).then(common.checkStatus).then(function (response) {\n        return response.json().then(function (json) {\n          _this3.set(json);\n          return Promise.resolve();\n        });\n      });\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.authDataStorage.removeItem(common.USER_AUTH_KEY);\n      this.authDataStorage.removeItem(common.REFRESH_TOKEN_KEY);\n      this.clearImpersonation();\n    }\n  }, {\n    key: 'getRefreshToken',\n    value: function getRefreshToken() {\n      return this.authDataStorage.getItem(common.REFRESH_TOKEN_KEY);\n    }\n  }, {\n    key: 'set',\n    value: function set(json) {\n      var rt = json['refreshToken'];\n      delete json['refreshToken'];\n\n      console.log('basfsaf', _jsBase.Base64);\n      var c = _jsBase.Base64.encode;\n      this.authDataStorage.setItem(common.USER_AUTH_KEY, c(JSON.stringify(json)));\n      this.authDataStorage.setItem(common.REFRESH_TOKEN_KEY, rt);\n    }\n  }, {\n    key: 'get',\n    value: function get() {\n      if (this.authDataStorage.getItem(common.USER_AUTH_KEY) === null) {\n        return null;\n      }\n      return JSON.parse(_jsBase.Base64.decode(this.authDataStorage.getItem(common.USER_AUTH_KEY)));\n    }\n  }, {\n    key: 'authedId',\n    value: function authedId() {\n      var id = ((this.get() || {}).user || {})._id;\n      if (id) {\n        return { '$oid': id };\n      }\n    }\n  }, {\n    key: 'isImpersonatingUser',\n    value: function isImpersonatingUser() {\n      return this.authDataStorage.getItem(common.IMPERSONATION_ACTIVE_KEY) === 'true';\n    }\n  }, {\n    key: 'refreshImpersonation',\n    value: function refreshImpersonation(client) {\n      var _this4 = this;\n\n      var userId = this.authDataStorage.getItem(common.IMPERSONATION_USER_KEY);\n      return client._doAuthed('/admin/users/' + userId + '/impersonate', 'POST', { refreshOnFailure: false, useRefreshToken: true }).then(function (response) {\n        return response.json().then(function (json) {\n          json['refreshToken'] = _this4.authDataStorage.getItem(common.REFRESH_TOKEN_KEY);\n          _this4.set(json);\n          return Promise.resolve();\n        });\n      }).catch(function (e) {\n        _this4.stopImpersonation();\n        throw e;\n      });\n    }\n  }, {\n    key: 'startImpersonation',\n    value: function startImpersonation(client, userId) {\n      if (this.get() === null) {\n        return Promise.reject(new common.BaasError('Must auth first'));\n      }\n      if (this.isImpersonatingUser()) {\n        throw new common.BaasError('Already impersonating a user');\n      }\n      this.authDataStorage.setItem(common.IMPERSONATION_ACTIVE_KEY, 'true');\n      this.authDataStorage.setItem(common.IMPERSONATION_USER_KEY, userId);\n\n      var realUserAuth = JSON.parse(_jsBase.Base64.decode(this.authDataStorage.getItem(common.USER_AUTH_KEY)));\n      realUserAuth['refreshToken'] = this.authDataStorage.getItem(common.REFRESH_TOKEN_KEY);\n      this.authDataStorage.setItem(common.IMPERSONATION_REAL_USER_AUTH_KEY, _jsBase.Base64.encode(JSON.stringify(realUserAuth)));\n      return this.refreshImpersonation(client);\n    }\n  }, {\n    key: 'stopImpersonation',\n    value: function stopImpersonation() {\n      var root = this;\n      return new Promise(function (resolve, reject) {\n        if (!root.isImpersonatingUser()) {\n          throw new common.BaasError('Not impersonating a user');\n        }\n        var realUserAuth = JSON.parse(_jsBase.Base64.decode(this.authDataStorage.getItem(common.IMPERSONATION_REAL_USER_AUTH_KEY)));\n        root.set(realUserAuth);\n        root.clearImpersonation();\n        resolve();\n      });\n    }\n  }, {\n    key: 'clearImpersonation',\n    value: function clearImpersonation() {\n      this.authDataStorage.removeItem(common.IMPERSONATION_ACTIVE_KEY);\n      this.authDataStorage.removeItem(common.IMPERSONATION_USER_KEY);\n      this.authDataStorage.removeItem(common.IMPERSONATION_REAL_USER_AUTH_KEY);\n    }\n  }], [{\n    key: 'generateState',\n    value: function generateState() {\n      var alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n      var state = '';\n      var stateLength = 64;\n      for (var i = 0; i < stateLength; i++) {\n        var pos = Math.floor(Math.random() * alpha.length);\n        state += alpha.substring(pos, pos + 1);\n      }\n      return state;\n    }\n  }]);\n\n  return Auth;\n}();\n\nexports.default = Auth;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./distribution/auth.js\n// module id = 1\n// module chunks = 0 1","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar JSONTYPE = exports.JSONTYPE = 'application/json';\nvar USER_AUTH_KEY = exports.USER_AUTH_KEY = '_baas_ua';\nvar REFRESH_TOKEN_KEY = exports.REFRESH_TOKEN_KEY = '_baas_rt';\nvar STATE_KEY = exports.STATE_KEY = '_baas_state';\nvar BAAS_ERROR_KEY = exports.BAAS_ERROR_KEY = '_baas_error';\nvar BAAS_LINK_KEY = exports.BAAS_LINK_KEY = '_baas_link';\nvar IMPERSONATION_ACTIVE_KEY = exports.IMPERSONATION_ACTIVE_KEY = '_baas_impers_active';\nvar IMPERSONATION_USER_KEY = exports.IMPERSONATION_USER_KEY = '_baas_impers_user';\nvar IMPERSONATION_REAL_USER_AUTH_KEY = exports.IMPERSONATION_REAL_USER_AUTH_KEY = '_baas_impers_real_ua';\n\nvar DEFAULT_BAAS_SERVER_URL = exports.DEFAULT_BAAS_SERVER_URL = 'https://baas-dev.10gen.cc';\n\nvar checkStatus = exports.checkStatus = function checkStatus(response) {\n  if (response.status >= 200 && response.status < 300) {\n    return response;\n  } else {\n    var error = new Error(response.statusText);\n    error.response = response;\n    throw error;\n  }\n};\n\nvar parseRedirectFragment = exports.parseRedirectFragment = function parseRedirectFragment(fragment, ourState) {\n  // After being redirected from oauth, the URL will look like:\n  // https://todo.examples.baas-dev.10gen.cc/#_baas_state=...&_baas_ua=...\n  // This function parses out baas-specific tokens from the fragment and\n  // builds an object describing the result.\n  var vars = fragment.split('&');\n  var result = { ua: null, found: false, stateValid: false, lastError: null };\n  var shouldBreak = false;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = vars[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var pair = _step.value;\n\n      var pairParts = pair.split('=');\n      var pairKey = decodeURIComponent(pairParts[0]);\n      switch (pairKey) {\n        case BAAS_ERROR_KEY:\n          result.lastError = decodeURIComponent(pairParts[1]);\n          result.found = true;\n          shouldBreak = true;\n          break;\n        case USER_AUTH_KEY:\n          result.ua = JSON.parse(window.atob(decodeURIComponent(pairParts[1])));\n          result.found = true;\n          continue;\n        case BAAS_LINK_KEY:\n          result.found = true;\n          continue;\n        case STATE_KEY:\n          result.found = true;\n          var theirState = decodeURIComponent(pairParts[1]);\n          if (ourState && ourState === theirState) {\n            result.stateValid = true;\n          }\n      }\n      if (shouldBreak) {\n        break;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return result;\n};\n\nvar BaasError = exports.BaasError = function (_Error) {\n  _inherits(BaasError, _Error);\n\n  function BaasError(message, code) {\n    _classCallCheck(this, BaasError);\n\n    var _this = _possibleConstructorReturn(this, (BaasError.__proto__ || Object.getPrototypeOf(BaasError)).call(this, message));\n\n    _this.name = 'BaasError';\n    _this.message = message;\n    if (code !== undefined) {\n      _this.code = code;\n    }\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(_this, _this.constructor);\n    } else {\n      _this.stack = new Error(message).stack;\n    }\n    return _this;\n  }\n\n  return BaasError;\n}(Error);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./distribution/common.js\n// module id = 2\n// module chunks = 0 1","/*\n * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $\n *\n *  Licensed under the MIT license.\n *    http://opensource.org/licenses/mit-license\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n */\n\n(function(global) {\n    'use strict';\n    // existing version for noConflict()\n    var _Base64 = global.Base64;\n    var version = \"2.1.9\";\n    // if node.js, we use Buffer\n    var buffer;\n    if (typeof module !== 'undefined' && module.exports) {\n        try {\n            buffer = require('buffer').Buffer;\n        } catch (err) {}\n    }\n    // constants\n    var b64chars\n        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    var b64tab = function(bin) {\n        var t = {};\n        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;\n        return t;\n    }(b64chars);\n    var fromCharCode = String.fromCharCode;\n    // encoder stuff\n    var cb_utob = function(c) {\n        if (c.length < 2) {\n            var cc = c.charCodeAt(0);\n            return cc < 0x80 ? c\n                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))\n                                + fromCharCode(0x80 | (cc & 0x3f)))\n                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))\n                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))\n                   + fromCharCode(0x80 | ( cc         & 0x3f)));\n        } else {\n            var cc = 0x10000\n                + (c.charCodeAt(0) - 0xD800) * 0x400\n                + (c.charCodeAt(1) - 0xDC00);\n            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))\n                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))\n                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))\n                    + fromCharCode(0x80 | ( cc         & 0x3f)));\n        }\n    };\n    var re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n    var utob = function(u) {\n        return u.replace(re_utob, cb_utob);\n    };\n    var cb_encode = function(ccc) {\n        var padlen = [0, 2, 1][ccc.length % 3],\n        ord = ccc.charCodeAt(0) << 16\n            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)\n            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),\n        chars = [\n            b64chars.charAt( ord >>> 18),\n            b64chars.charAt((ord >>> 12) & 63),\n            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),\n            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)\n        ];\n        return chars.join('');\n    };\n    var btoa = global.btoa ? function(b) {\n        return global.btoa(b);\n    } : function(b) {\n        return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n    };\n    var _encode = buffer ? function (u) {\n        return (u.constructor === buffer.constructor ? u : new buffer(u))\n        .toString('base64')\n    }\n    : function (u) { return btoa(utob(u)) }\n    ;\n    var encode = function(u, urisafe) {\n        return !urisafe\n            ? _encode(String(u))\n            : _encode(String(u)).replace(/[+\\/]/g, function(m0) {\n                return m0 == '+' ? '-' : '_';\n            }).replace(/=/g, '');\n    };\n    var encodeURI = function(u) { return encode(u, true) };\n    // decoder stuff\n    var re_btou = new RegExp([\n        '[\\xC0-\\xDF][\\x80-\\xBF]',\n        '[\\xE0-\\xEF][\\x80-\\xBF]{2}',\n        '[\\xF0-\\xF7][\\x80-\\xBF]{3}'\n    ].join('|'), 'g');\n    var cb_btou = function(cccc) {\n        switch(cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                |    ((0x3f & cccc.charCodeAt(1)) << 12)\n                |    ((0x3f & cccc.charCodeAt(2)) <<  6)\n                |     (0x3f & cccc.charCodeAt(3)),\n            offset = cp - 0x10000;\n            return (fromCharCode((offset  >>> 10) + 0xD800)\n                    + fromCharCode((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return fromCharCode(\n                ((0x0f & cccc.charCodeAt(0)) << 12)\n                    | ((0x3f & cccc.charCodeAt(1)) << 6)\n                    |  (0x3f & cccc.charCodeAt(2))\n            );\n        default:\n            return  fromCharCode(\n                ((0x1f & cccc.charCodeAt(0)) << 6)\n                    |  (0x3f & cccc.charCodeAt(1))\n            );\n        }\n    };\n    var btou = function(b) {\n        return b.replace(re_btou, cb_btou);\n    };\n    var cb_decode = function(cccc) {\n        var len = cccc.length,\n        padlen = len % 4,\n        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)\n            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)\n            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)\n            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),\n        chars = [\n            fromCharCode( n >>> 16),\n            fromCharCode((n >>>  8) & 0xff),\n            fromCharCode( n         & 0xff)\n        ];\n        chars.length -= [0, 0, 2, 1][padlen];\n        return chars.join('');\n    };\n    var atob = global.atob ? function(a) {\n        return global.atob(a);\n    } : function(a){\n        return a.replace(/[\\s\\S]{1,4}/g, cb_decode);\n    };\n    var _decode = buffer ? function(a) {\n        return (a.constructor === buffer.constructor\n                ? a : new buffer(a, 'base64')).toString();\n    }\n    : function(a) { return btou(atob(a)) };\n    var decode = function(a){\n        return _decode(\n            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })\n                .replace(/[^A-Za-z0-9\\+\\/]/g, '')\n        );\n    };\n    var noConflict = function() {\n        var Base64 = global.Base64;\n        global.Base64 = _Base64;\n        return Base64;\n    };\n    // export Base64\n    global.Base64 = {\n        VERSION: version,\n        atob: atob,\n        btoa: btoa,\n        fromBase64: decode,\n        toBase64: encode,\n        utob: utob,\n        encode: encode,\n        encodeURI: encodeURI,\n        btou: btou,\n        decode: decode,\n        noConflict: noConflict\n    };\n    // if ES5 is available, make Base64.extendString() available\n    if (typeof Object.defineProperty === 'function') {\n        var noEnum = function(v){\n            return {value:v,enumerable:false,writable:true,configurable:true};\n        };\n        global.Base64.extendString = function () {\n            Object.defineProperty(\n                String.prototype, 'fromBase64', noEnum(function () {\n                    return decode(this)\n                }));\n            Object.defineProperty(\n                String.prototype, 'toBase64', noEnum(function (urisafe) {\n                    return encode(this, urisafe)\n                }));\n            Object.defineProperty(\n                String.prototype, 'toBase64URI', noEnum(function () {\n                    return encode(this, true)\n                }));\n        };\n    }\n    // that's it!\n    if (global['Meteor']) {\n       Base64 = global.Base64; // for normal export in Meteor.js\n    }\n})(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/js-base64/base64.js\n// module id = 3\n// module chunks = 0 1","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/buffer/index.js\n// module id = 4\n// module chunks = 0 1","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 5\n// module chunks = 0 1","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ieee754/index.js\n// module id = 6\n// module chunks = 0 1","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isarray/index.js\n// module id = 7\n// module chunks = 0 1","// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\nrequire('whatwg-fetch');\nmodule.exports = self.fetch.bind(self);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isomorphic-fetch/fetch-npm-browserify.js\n// module id = 8\n// module chunks = 0 1","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/whatwg-fetch/fetch.js\n// module id = 9\n// module chunks = 0 1"],"sourceRoot":""}